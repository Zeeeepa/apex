#!/usr/bin/env bun

import { runAgent as runAttackSurfaceAgent } from "../src/core/agent/attackSurfaceAgent/agent";
import { runPentestPipeline } from "../src/core/agent/orchestrator/pipeline";
import { Session } from "../src/core/session";
import type { AIModel } from "../src/core/ai";
import { join, resolve } from "path";
import { existsSync, readFileSync } from "fs";
import { generateRandomName } from "../src/util/name";
import {
  createSandboxedExecutor,
  type RuntimeSandboxConfig,
} from "../src/core/sandbox/runtime-sandbox";
import { spawn } from "child_process";

interface EnumerationResult {
  target: string;
  canonical_endpoints: Array<{
    path: string;
    status: number;
    is_catch_all: boolean;
    variant_count: number;
  }>;
  auth_discovery?: {
    discovered: boolean;
    authenticated: boolean;
    endpoints: Array<{
      url: string;
      type: string;
      method: string;
      detected_fields?: string[];
      status_code: number;
    }>;
    registration_available?: boolean;
    login_endpoint?: string;
    register_endpoint?: string;
    auth_type?: string;
    summary?: string;
  };
  stats?: {
    total_paths_tested: number;
    total_filtered_noise: number;
  };
}

/**
 * Run katana + feroxagent enumeration
 */
async function runEnumeration(target: string, quiet: boolean): Promise<EnumerationResult | null> {
  return new Promise((resolve) => {
    if (!quiet) {
      console.log(`\n${colors.cyan}[Enumeration]${colors.reset} Running katana | feroxagent on ${target}...`);
    }

    // Run: katana -u <target> | feroxagent -u <target> --json -d 3 -t 20
    const child = spawn("bash", [
      "-c",
      `katana -u "${target}" -silent 2>/dev/null | feroxagent -u "${target}" --json -d 3 -t 20 2>/dev/null`
    ], {
      stdio: ["ignore", "pipe", "pipe"],
    });

    let stdout = "";
    let stderr = "";

    child.stdout.on("data", (data) => {
      stdout += data.toString();
    });

    child.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    // Timeout after 5 minutes
    const timeout = setTimeout(() => {
      child.kill("SIGTERM");
      if (!quiet) {
        console.log(`${colors.yellow}[Enumeration]${colors.reset} Timed out after 5 minutes`);
      }
      resolve(null);
    }, 5 * 60 * 1000);

    child.on("close", (code) => {
      clearTimeout(timeout);

      if (code !== 0 && !stdout.includes('"canonical_endpoints"')) {
        if (!quiet) {
          console.log(`${colors.yellow}[Enumeration]${colors.reset} Failed (exit code ${code}). Continuing without pre-enumeration.`);
          if (stderr) {
            console.log(`  ${colors.dim}${stderr.substring(0, 200)}${colors.reset}`);
          }
        }
        resolve(null);
        return;
      }

      // Parse the JSON output (may be mixed with other output)
      try {
        // Find the JSON object in the output
        const jsonStart = stdout.indexOf("{");
        const jsonEnd = stdout.lastIndexOf("}");
        if (jsonStart !== -1 && jsonEnd !== -1) {
          const jsonStr = stdout.substring(jsonStart, jsonEnd + 1);
          const result = JSON.parse(jsonStr) as EnumerationResult;
          if (!quiet) {
            console.log(`${colors.green}[Enumeration]${colors.reset} Found ${result.canonical_endpoints?.length || 0} endpoints`);
            if (result.auth_discovery?.discovered) {
              console.log(`  ${colors.dim}Auth discovered: ${result.auth_discovery.summary || "yes"}${colors.reset}`);
            }
          }
          resolve(result);
        } else {
          resolve(null);
        }
      } catch (e) {
        if (!quiet) {
          console.log(`${colors.yellow}[Enumeration]${colors.reset} Failed to parse output. Continuing without pre-enumeration.`);
        }
        resolve(null);
      }
    });

    child.on("error", (err) => {
      clearTimeout(timeout);
      if (!quiet) {
        console.log(`${colors.yellow}[Enumeration]${colors.reset} Error: ${err.message}. Continuing without pre-enumeration.`);
      }
      resolve(null);
    });
  });
}

// ANSI color codes for better visibility
const colors = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  dim: "\x1b[2m",
  cyan: "\x1b[36m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  red: "\x1b[31m",
  magenta: "\x1b[35m",
  blue: "\x1b[34m",
  gray: "\x1b[90m",
};

/**
 * Truncate a string for display
 */
function truncate(str: string, maxLen: number = 500): string {
  if (str.length <= maxLen) return str;
  return str.substring(0, maxLen) + `... (${str.length - maxLen} more chars)`;
}

/**
 * Format tool arguments for display
 */
function formatArgs(args: any): string {
  if (!args) return "";
  const { toolCallDescription, ...rest } = args;
  if (Object.keys(rest).length === 0) return "";

  try {
    const formatted = JSON.stringify(rest, null, 2);
    return truncate(formatted, 1000);
  } catch {
    return String(args);
  }
}

/**
 * Format tool result for display
 */
function formatResult(result: any): string {
  if (!result) return "(no result)";

  try {
    // Handle common result structures
    if (typeof result === "string") {
      return truncate(result, 800);
    }

    if (result.success !== undefined) {
      const status = result.success ? `${colors.green}✓ success${colors.reset}` : `${colors.red}✗ failed${colors.reset}`;
      let output = status;

      if (result.error) {
        output += `\n    Error: ${truncate(result.error, 200)}`;
      }
      if (result.stdout) {
        output += `\n    stdout: ${truncate(result.stdout, 500)}`;
      }
      if (result.body) {
        output += `\n    body: ${truncate(result.body, 500)}`;
      }
      if (result.status) {
        output += `\n    status: ${result.status}`;
      }
      if (result.message) {
        output += `\n    message: ${truncate(result.message, 300)}`;
      }
      return output;
    }

    const formatted = JSON.stringify(result, null, 2);
    return truncate(formatted, 800);
  } catch {
    return truncate(String(result), 500);
  }
}

interface PentestOptions {
  target: string;
  model: AIModel;
  whitebox: boolean;
  sourcePath?: string;
  workspace: string;
  concurrency: number;
  focusEndpoint?: string;
  skipAttackSurface: boolean;
  /** Skip the katana+feroxagent enumeration step */
  skipEnumeration: boolean;
  /** Paths to block from the agent (for blackbox mode) */
  blockedPaths?: string[];
  /** Block Docker container access */
  blockDocker?: boolean;
  /** Verbose logging */
  verbose?: boolean;
  /** Quiet mode - minimal output */
  quiet?: boolean;
}

async function runPentest(options: PentestOptions): Promise<void> {
  console.log("=".repeat(80));
  console.log("APEX PENTEST PIPELINE");
  console.log("=".repeat(80));
  console.log(`Target: ${options.target}`);
  console.log(`Model: ${options.model}`);
  console.log(`Mode: ${options.whitebox ? "Whitebox" : "Blackbox"}`);
  console.log(`Workspace: ${options.workspace}`);
  console.log(`Concurrency: ${options.concurrency}`);

  // Create sandbox if blocking is enabled
  let toolOverride: { execute_command?: (opts: any) => Promise<any> } | undefined;
  if (options.blockedPaths?.length || options.blockDocker) {
    const sandboxConfig: RuntimeSandboxConfig = {
      blockedPaths: options.blockedPaths || [],
      blockDockerAccess: options.blockDocker ?? false,
    };
    toolOverride = {
      execute_command: createSandboxedExecutor(sandboxConfig),
    };
    console.log(`Sandbox: ENABLED`);
    if (options.blockedPaths?.length) {
      console.log(`  Blocked paths: ${options.blockedPaths.join(", ")}`);
    }
    if (options.blockDocker) {
      console.log(`  Docker access: BLOCKED`);
    }
  }

  console.log("=".repeat(80));

  // Create session
  const session = await Session.create({
    targets: [options.target],
    name: generateRandomName(),
    prefix: "pentest-",
    config: {
      mode: "auto",
      outcomeGuidance: Session.DEFAULT_OUTCOME_GUIDANCE,
    },
  });

  console.log(`\nSession ID: ${session.id}`);
  console.log(`Session Path: ${session.rootPath}\n`);

  const attackSurfacePath = join(session.rootPath, "attack-surface-results.json");

  // Phase 1: Attack Surface (unless skipped)
  if (!options.skipAttackSurface) {
    console.log("=".repeat(80));
    console.log("PHASE 1: ATTACK SURFACE MAPPING");
    console.log("=".repeat(80));

    // Step 1a: Run enumeration (katana + feroxagent) unless skipped
    const enumResult = options.skipEnumeration
      ? null
      : await runEnumeration(options.target, options.quiet ?? false);

    // Step 1b: Build enumeration context for the agent
    let enumerationContext: string | undefined;

    if (enumResult) {
      // Save enumeration results to session
      const enumPath = join(session.rootPath, "enumeration-results.json");
      const { writeFileSync } = await import("fs");
      writeFileSync(enumPath, JSON.stringify(enumResult, null, 2));

      enumerationContext = `## Pre-Enumeration Results (from katana + feroxagent)

**Target:** ${enumResult.target}
**Endpoints Found:** ${enumResult.canonical_endpoints?.length || 0}

### Discovered Endpoints:
${enumResult.canonical_endpoints?.map(ep => `- ${ep.path} (status: ${ep.status})`).join("\n") || "None"}

${enumResult.auth_discovery?.discovered ? `
### Authentication Discovery:
${enumResult.auth_discovery.summary || "Authentication endpoints found"}
- Login: ${enumResult.auth_discovery.login_endpoint || "N/A"}
- Register: ${enumResult.auth_discovery.register_endpoint || "N/A"}
- Registration available: ${enumResult.auth_discovery.registration_available ? "Yes" : "No"}

**IMPORTANT:** Since authentication was discovered, you MUST call the delegate_to_auth_subagent tool to:
1. Register a new user (if registration is available)
2. Login and obtain session credentials
3. Use those credentials to explore authenticated endpoints (401 status endpoints)
` : ""}

## Your Task:
1. Review the discovered endpoints above
2. ${enumResult.auth_discovery?.discovered ? "Call delegate_to_auth_subagent to authenticate" : "Check if authentication is needed"}
3. Explore any additional endpoints not found by enumeration
4. Document all assets using document_asset
5. Create the final attack surface report using create_attack_surface_report`;
    }

    const { streamResult } = await runAttackSurfaceAgent({
      target: options.target,
      objective: "Map the complete attack surface",
      model: options.model,
      session,
      toolOverride,
      enumerationContext,
    });

    // Stream output with detailed logging
    let currentToolCall: string | null = null;
    const quiet = options.quiet;
    const verbose = options.verbose;

    for await (const delta of streamResult.fullStream) {
      const eventType = delta.type;

      if (eventType === "text-delta") {
        if (!quiet) {
          process.stdout.write(delta.text);
        }
      } else if (eventType === "tool-call") {
        currentToolCall = delta.toolName;
        // Tool call deltas logged only in verbose mode
        if (verbose) {
          const args = (delta as any).args || (delta as any).input;
          const description = args?.toolCallDescription || "";
          console.log(`\n${colors.dim}[Tool Call]${colors.reset} ${delta.toolName}${description ? `: ${description}` : ""}`);
        }
      } else if (eventType === "tool-result") {
        if (!quiet) {
          const result = (delta as any).result;
          console.log(`${colors.green}[Tool Result]${colors.reset} ${currentToolCall || "unknown"}`);
          const formattedResult = formatResult(result);
          formattedResult.split("\n").forEach((line) => console.log(`  ${line}`));
          console.log("");
        }
        currentToolCall = null;
      } else if (eventType === "error") {
        // Always show errors
        console.log(`\n${colors.red}[Error]${colors.reset} ${(delta as any).error?.message || JSON.stringify(delta)}`);
      } else if (eventType === "finish") {
        if (!quiet) {
          console.log(`\n${colors.green}[Finished]${colors.reset} Stream complete`);
        }
      } else if (verbose) {
        // Log other event types for debugging in verbose mode
        console.log(`\n${colors.dim}[${eventType}]${colors.reset}`, JSON.stringify(delta).substring(0, 200));
      }
    }

    console.log("\n");

    if (!existsSync(attackSurfacePath)) {
      console.error("Error: Attack surface agent did not produce results");
      process.exit(1);
    }

    console.log(`✓ Attack surface saved to: ${attackSurfacePath}`);
  } else {
    if (!existsSync(attackSurfacePath)) {
      console.error("Error: --skip-attack-surface requires existing results");
      process.exit(1);
    }
    console.log(`Using existing attack surface: ${attackSurfacePath}`);
  }

  // Phase 2: Pentest Pipeline
  console.log("\n");
  console.log("=".repeat(80));
  console.log("PHASE 2: VULNERABILITY TESTING");
  console.log("=".repeat(80));

  let totalSubAgents = 0;
  let completedSubAgents = 0;

  const result = await runPentestPipeline({
    attackSurfacePath,
    session,
    model: options.model,
    workspace: options.workspace,
    whiteboxMode: options.whitebox,
    sourceCodePath: options.sourcePath,
    focusEndpoint: options.focusEndpoint,
    concurrencyLimit: options.concurrency,
    toolOverride,
    blockedPaths: options.blockedPaths,
    onOrchestratorComplete: (manifest) => {
      totalSubAgents = manifest.subagents.length;
      console.log(`\nOrchestrator spawned ${totalSubAgents} sub-agents`);
    },
    onSubAgentStart: (id, endpoint, vulnClass) => {
      console.log(`  [${id}] Testing ${vulnClass} on ${endpoint}`);
    },
    onSubAgentComplete: (subAgentResult) => {
      completedSubAgents++;
      const status = subAgentResult.success ? `${colors.green}✓${colors.reset}` : `${colors.red}✗${colors.reset}`;
      const findings = subAgentResult.findings.length;
      const findingsStr = findings > 0 ? `${colors.yellow}${findings} findings${colors.reset}` : "0 findings";
      console.log(`  ${status} [${completedSubAgents}/${totalSubAgents}] ${subAgentResult.subagentId}: ${findingsStr}`);
    },
  });

  // Summary
  console.log("\n");
  console.log("=".repeat(80));
  console.log("RESULTS");
  console.log("=".repeat(80));
  console.log(result.summary);
  console.log(`\nFindings saved to: ${session.rootPath}`);

  if (result.allFindings.length > 0) {
    console.log("\nFindings:");
    for (const finding of result.allFindings) {
      console.log(`  [${finding.severity.toUpperCase()}] ${finding.title}`);
      console.log(`    Endpoint: ${finding.endpoint}`);
    }
  }
  process.exit(0);
}

// CLI parsing
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0 || args.includes("--help") || args.includes("-h")) {
    console.log(`Usage: bun run scripts/pentest.ts <target-url> [options]

Options:
  --model <model>       AI model (default: claude-sonnet-4-5)
  --whitebox            Enable whitebox mode
  --source-path <path>  Source code path (required with --whitebox)
  --workspace <name>    Workspace name for memory
  --concurrency <n>     Max parallel sub-agents (default: 10)
  --focus <endpoint>    Focus on specific endpoint
  --skip-attack-surface Use existing attack surface results
  --skip-enum           Skip katana+feroxagent enumeration
  --help                Show this help

Logging options:
  --verbose             Show all stream events (including debug info)
  --quiet               Minimal output (errors only)

Sandbox options (for blackbox benchmarks):
  --block-source <path> Block access to source code directory (can repeat)
  --block-docker        Block Docker exec/inspect/logs commands
`);
    process.exit(args.length === 0 ? 1 : 0);
  }

  // Parse target (first non-flag argument)
  let target = "";
  for (const arg of args) {
    if (!arg.startsWith("-")) {
      target = arg;
      break;
    }
  }

  if (!target) {
    console.error("Error: target URL is required");
    process.exit(1);
  }

  // Parse options
  const modelIndex = args.indexOf("--model");
  const model = (modelIndex !== -1 ? args[modelIndex + 1] : "claude-sonnet-4-5") as AIModel;

  const whitebox = args.includes("--whitebox");

  const sourcePathIndex = args.indexOf("--source-path");
  const sourcePath = sourcePathIndex !== -1 ? args[sourcePathIndex + 1] : undefined;

  if (whitebox && !sourcePath) {
    console.error("Error: --whitebox requires --source-path");
    process.exit(1);
  }

  let workspace: string;
  const workspaceIndex = args.indexOf("--workspace");
  if (workspaceIndex !== -1) {
    workspace = args[workspaceIndex + 1];
  } else {
    try {
      workspace = new URL(target).hostname.replace(/\./g, "-");
    } catch {
      // If target isn't a valid URL, use it directly with dots replaced
      workspace = target.replace(/\./g, "-").replace(/[^a-zA-Z0-9-]/g, "");
    }
  }

  const concurrencyIndex = args.indexOf("--concurrency");
  const concurrency = concurrencyIndex !== -1
    ? parseInt(args[concurrencyIndex + 1], 10)
    : 10;

  const focusIndex = args.indexOf("--focus");
  const focusEndpoint = focusIndex !== -1 ? args[focusIndex + 1] : undefined;

  const skipAttackSurface = args.includes("--skip-attack-surface");
  const skipEnumeration = args.includes("--skip-enum");

  // Parse sandbox options
  const blockedPaths: string[] = [];
  for (let i = 0; i < args.length; i++) {
    if (args[i] === "--block-source" && args[i + 1]) {
      blockedPaths.push(resolve(args[i + 1]));
    }
  }

  const blockDocker = args.includes("--block-docker");
  const verbose = args.includes("--verbose");
  const quiet = args.includes("--quiet");

  // Set DEBUG env var for verbose mode
  if (verbose) {
    process.env.DEBUG = "1";
  }

  await runPentest({
    target,
    model,
    whitebox,
    sourcePath,
    workspace,
    concurrency,
    focusEndpoint,
    skipAttackSurface,
    skipEnumeration,
    blockedPaths: blockedPaths.length > 0 ? blockedPaths : undefined,
    blockDocker: blockDocker || undefined,
    verbose,
    quiet,
  });
}

main().catch((error) => {
  console.error("Fatal error:", error.message);
  process.exit(1);
});

export { runPentest };
