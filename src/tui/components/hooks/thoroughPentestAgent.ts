import { useState } from "react";
import { useAgent } from "../../agentProvider";
import { existsSync } from "fs";
import {
  runStreamlinedPentest,
  type StreamlinedPentestProgress,
} from "../../../core/agent/thoroughPentestAgent/streamlined";
import type { SubAgentSpawnInfo, SubAgentStreamEvent } from "../../../core/agent/pentestAgent/orchestrator";
import type { MetaVulnerabilityTestResult } from "../../../core/agent/metaTestingAgent";
import type { Message, ToolMessage } from "../../../core/messages/types";
import { exec } from "child_process";

export type Subagent = {
  id: string;
  name: string;
  type: "attack-surface" | "pentest";
  target: string;
  messages: Message[];
  createdAt: Date;
  status: "pending" | "completed" | "failed";
};

export default function useThoroughPentestAgent() {
  const [target, setTarget] = useState("");
  const [authenticationInstructions, setAuthenticationInstructions] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [hasStarted, setHasStarted] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [sessionPath, setSessionPath] = useState<string>("");
  const [subagents, setSubagents] = useState<Subagent[]>([]);
  const [abortController, setAbortController] =
    useState<AbortController | null>(null);

  const {
    model,
    addTokens,
    setTokenCount,
    setThinking,
    isExecuting,
    setIsExecuting,
  } = useAgent();

  function openReport() {
    if (sessionPath) {
      const reportPath = `${sessionPath}/comprehensive-pentest-report.md`;
      // Try comprehensive report first, fall back to session directory
      if (existsSync(reportPath)) {
        exec(`open "${reportPath}"`, (error) => {
          if (error) {
            console.error("Error opening report:", error);
          }
        });
      } else {
        // Open the session directory if report doesn't exist yet
        exec(`open "${sessionPath}"`, (error) => {
          if (error) {
            console.error("Error opening session:", error);
          }
        });
      }
    }
  }

  async function beginExecution(sessionConfig?: any) {
    if (target && !hasStarted) {
      setHasStarted(true);
      setThinking(true);
      setIsExecuting(true);

      // Create new abort controller for this execution
      const controller = new AbortController();
      setAbortController(controller);

      // Track current assistant text for streaming
      let currentDiscoveryText = "";

      try {
        // Add initial user message
        const userMessage: Message = {
          role: "user",
          content: `Target: ${target}\n\nMode: Streamlined Pentest (Meta Agent with Cognitive Loop)`,
          createdAt: new Date(),
        };
        setMessages([userMessage]);

        // Add discovery subagent
        const discoverySubagent: Subagent = {
          id: "attack-surface-discovery",
          name: "Attack Surface Discovery",
          type: "attack-surface",
          target,
          messages: [],
          status: "pending",
          createdAt: new Date(),
        };
        setSubagents([discoverySubagent]);

        // Run the streamlined pentest with streaming callbacks
        const result = await runStreamlinedPentest({
          target,
          model: model.id,
          sessionConfig: {
            ...sessionConfig,
            authenticationInstructions: authenticationInstructions || undefined,
          },
          abortSignal: controller.signal,

          // Discovery phase step finish - for token tracking
          onDiscoveryStepFinish: (step) => {
            const stepTokens =
              (step.usage?.inputTokens ?? 0) + (step.usage?.outputTokens ?? 0);
            if (stepTokens > 0) {
              setTokenCount(stepTokens);
            }
          },

          // Discovery phase stream - for TUI message updates
          onDiscoveryStream: (chunk) => {
            if (chunk.type === "text-delta") {
              currentDiscoveryText += chunk.textDelta;
              addTokens(1);

              // Update discovery subagent messages
              setSubagents((prev) => {
                const discoveryIdx = prev.findIndex((s) => s.id === "attack-surface-discovery");
                if (discoveryIdx === -1) return prev;

                const updated = [...prev];
                const subagent = updated[discoveryIdx]!;
                const lastMsg = subagent.messages[subagent.messages.length - 1];

                if (lastMsg && lastMsg.role === "assistant") {
                  // Update existing assistant message
                  const newMessages = [...subagent.messages];
                  newMessages[newMessages.length - 1] = {
                    ...lastMsg,
                    content: currentDiscoveryText,
                  };
                  updated[discoveryIdx] = { ...subagent, messages: newMessages };
                } else {
                  // Create new assistant message
                  updated[discoveryIdx] = {
                    ...subagent,
                    messages: [
                      ...subagent.messages,
                      {
                        role: "assistant",
                        content: currentDiscoveryText,
                        createdAt: new Date(),
                      },
                    ],
                  };
                }
                return updated;
              });
            } else if (chunk.type === "tool-call") {
              setThinking(false);
              currentDiscoveryText = "";

              // Add tool call message to discovery subagent
              const toolMessage: Message = {
                role: "tool",
                status: "pending",
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                content: (chunk as any).input?.toolCallDescription || `Calling ${chunk.toolName}`,
                args: (chunk as any).input,
                createdAt: new Date(),
              };

              setSubagents((prev) => {
                const discoveryIdx = prev.findIndex((s) => s.id === "attack-surface-discovery");
                if (discoveryIdx === -1) return prev;
                const updated = [...prev];
                updated[discoveryIdx] = {
                  ...updated[discoveryIdx]!,
                  messages: [...updated[discoveryIdx]!.messages, toolMessage],
                };
                return updated;
              });
            } else if (chunk.type === "tool-result") {
              setThinking(true);

              // Update tool message to completed
              setSubagents((prev) => {
                const discoveryIdx = prev.findIndex((s) => s.id === "attack-surface-discovery");
                if (discoveryIdx === -1) return prev;
                const updated = [...prev];
                const subagent = updated[discoveryIdx]!;
                const msgIdx = subagent.messages.findIndex(
                  (m) => m.role === "tool" && (m as ToolMessage).toolCallId === chunk.toolCallId
                );
                if (msgIdx === -1) return prev;

                const newMessages = [...subagent.messages];
                const existingMsg = newMessages[msgIdx] as ToolMessage;
                newMessages[msgIdx] = {
                  ...existingMsg,
                  status: "completed",
                  content: (chunk as any).input?.toolCallDescription
                    ? `âœ“ ${(chunk as any).input.toolCallDescription}`
                    : `âœ“ ${chunk.toolName}`,
                };
                updated[discoveryIdx] = { ...subagent, messages: newMessages };
                return updated;
              });
            }
          },

          // Pentest agent spawn callback
          onPentestAgentSpawn: (info: SubAgentSpawnInfo) => {
            setSubagents((prev) => {
              // First mark discovery as completed if it's still pending
              const discoveryIdx = prev.findIndex((s) => s.id === "attack-surface-discovery");
              const updated = discoveryIdx !== -1 && prev[discoveryIdx]?.status === "pending"
                ? prev.map((s, i) => i === discoveryIdx ? { ...s, status: "completed" as const } : s)
                : [...prev];

              // Add the new pentest subagent
              const newSubagent: Subagent = {
                id: info.id,
                name: info.name,
                type: "pentest",
                target: info.target,
                messages: [],
                status: "pending",
                createdAt: new Date(),
              };
              return [...updated, newSubagent];
            });
          },

          // Pentest agent stream callback
          onPentestAgentStream: (event: SubAgentStreamEvent) => {
            // Handle step-finish events from pentest agents
            if (event.type === "step-finish" && event.data) {
              const { text, toolCalls, toolResults, usage } = event.data;

              // Track tokens
              if (usage) {
                const stepTokens = (usage.inputTokens ?? 0) + (usage.outputTokens ?? 0);
                if (stepTokens > 0) {
                  addTokens(stepTokens);
                }
              }

              // Update agent messages
              setSubagents((prev) => {
                const agentIdx = prev.findIndex((s) => s.id === event.agentId);
                if (agentIdx === -1) return prev;

                const updated = [...prev];
                const subagent = updated[agentIdx]!;
                const newMessages = [...subagent.messages];

                // Add text if present
                if (text && text.trim()) {
                  const lastMsg = newMessages[newMessages.length - 1];
                  if (lastMsg && lastMsg.role === "assistant") {
                    newMessages[newMessages.length - 1] = {
                      ...lastMsg,
                      content: (lastMsg.content || "") + text,
                    };
                  } else {
                    newMessages.push({
                      role: "assistant",
                      content: text,
                      createdAt: new Date(),
                    });
                  }
                }

                // Add tool calls
                if (toolCalls && toolCalls.length > 0) {
                  for (const tc of toolCalls) {
                    newMessages.push({
                      role: "tool",
                      status: "pending",
                      toolCallId: tc.toolCallId,
                      toolName: tc.toolName,
                      content: tc.args?.toolCallDescription || `${tc.toolName}`,
                      args: tc.args,
                      createdAt: new Date(),
                    });
                  }
                }

                // Update tool results
                if (toolResults && toolResults.length > 0) {
                  for (const tr of toolResults) {
                    const msgIdx = newMessages.findIndex(
                      (m) => m.role === "tool" && (m as ToolMessage).toolCallId === tr.toolCallId
                    );
                    if (msgIdx !== -1) {
                      const existingMsg = newMessages[msgIdx] as ToolMessage;
                      newMessages[msgIdx] = {
                        ...existingMsg,
                        status: "completed",
                        content: `âœ“ ${existingMsg.toolName || "tool"}`,
                      };
                    }
                  }
                }

                updated[agentIdx] = { ...subagent, messages: newMessages };
                return updated;
              });
            }
          },

          // Pentest agent complete callback
          onPentestAgentComplete: (agentId: string, agentResult: MetaVulnerabilityTestResult) => {
            setSubagents((prev) =>
              prev.map((sub) =>
                sub.id === agentId
                  ? {
                      ...sub,
                      status: agentResult.error ? "failed" : "completed",
                      messages: [
                        ...sub.messages,
                        {
                          role: "assistant",
                          content: `${agentResult.findingsCount > 0 ? "âœ…" : "âšª"} ${agentResult.summary}`,
                          createdAt: new Date(),
                        },
                      ],
                    }
                  : sub
              )
            );
          },

          // Progress callback
          onProgress: (status: StreamlinedPentestProgress) => {
            const phaseIcons: Record<string, string> = {
              discovery: "ðŸ”",
              testing: "ðŸ”¬",
              reporting: "ðŸ“",
              complete: "âœ…",
            };

            const icon = phaseIcons[status.phase] || "â³";

            // Add progress as a main message
            setMessages((prev) => {
              const lastMsg = prev[prev.length - 1];
              const progressContent = `${icon} [${status.phase.toUpperCase()}] ${status.message}`;

              // Update or add progress message
              if (lastMsg && lastMsg.role === "assistant" && lastMsg.content?.startsWith(icon)) {
                const updated = [...prev];
                updated[updated.length - 1] = { ...lastMsg, content: progressContent };
                return updated;
              }

              return [...prev, { role: "assistant", content: progressContent, createdAt: new Date() }];
            });
          },
        });

        // Store session path for display
        setSessionPath(result.session.rootPath);

        // Add completion message
        if (result.success) {
          const completionMessage: Message = {
            role: "assistant",
            content: `âœ… Penetration test complete!\n\nðŸ“Š Results:\n- Targets tested: ${result.targets.length}\n- Total findings: ${result.totalFindings}\n${result.reportPath ? `- Report: ${result.reportPath}` : ""}`,
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, completionMessage]);

          // Check for report completion
          if (result.reportPath && existsSync(result.reportPath)) {
            setIsCompleted(true);
          } else if (
            existsSync(
              result.session.rootPath + "/comprehensive-pentest-report.md"
            )
          ) {
            setIsCompleted(true);
          }
        } else {
          const errorMessage: Message = {
            role: "assistant",
            content: `âš ï¸ Pentest completed with error: ${result.error || "Unknown error"}`,
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, errorMessage]);
        }

        setThinking(false);
        setIsExecuting(false);
      } catch (error) {
        console.error("Error during agent execution:", error);
        setThinking(false);
        setIsExecuting(false);

        // Check if this was an abort
        if (error instanceof Error && error.name === "AbortError") {
          const abortMessage: Message = {
            role: "assistant",
            content: "âš ï¸ Execution aborted by user",
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, abortMessage]);
        } else {
          const errorMessage: Message = {
            role: "assistant",
            content: `Error: ${
              error instanceof Error ? error.message : "Unknown error occurred"
            }`,
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, errorMessage]);
        }
      }
    }
  }

  return {
    target,
    setTarget,
    authenticationInstructions,
    setAuthenticationInstructions,
    messages,
    setMessages,
    hasStarted,
    setHasStarted,
    isCompleted,
    setIsCompleted,
    sessionPath,
    subagents,
    setSubagents,
    abortController,
    isExecuting,
    beginExecution,
    openReport,
  };
}
