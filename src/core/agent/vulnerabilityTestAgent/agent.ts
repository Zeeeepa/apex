import {
  tool,
  hasToolCall,
  type StreamTextOnStepFinishCallback,
  type ToolSet,
} from 'ai';
import { z } from 'zod';
import { streamResponse, type AIModel } from '../../ai';
import {
  createPentestTools,
  type ExecuteCommandOpts,
  type ExecuteCommandResult,
  type HttpRequestOpts,
  type HttpRequestResult,
} from '../tools';
import { Logger } from '../logger';
import type { Session } from '../sessions';
import { join } from 'path';
import {
  existsSync,
  writeFileSync,
  chmodSync,
  unlinkSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  appendFileSync,
} from 'fs';

/**
 * Save agent messages to a JSON file in the subagents directory
 */
function saveAgentMessages(
  sessionRootPath: string,
  agentName: string,
  messages: any[],
  metadata?: Record<string, any>
): string {
  const subagentsDir = join(sessionRootPath, 'subagents');
  if (!existsSync(subagentsDir)) {
    mkdirSync(subagentsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const sanitizedName = agentName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
  const filename = `${sanitizedName}-${timestamp}.json`;
  const filepath = join(subagentsDir, filename);

  const data = {
    agentName,
    timestamp: new Date().toISOString(),
    ...metadata,
    messages,
  };

  writeFileSync(filepath, JSON.stringify(data, null, 2));
  return filepath;
}
import { promisify } from 'util';
import { exec } from 'child_process';
import { nanoid } from 'nanoid';
import {
  buildSystemPrompt,
  getVulnerabilityClassName,
} from './prompts';
import type {
  VulnerabilityTestInput,
  VulnerabilityTestResult,
  VulnerabilityClass,
  CreatePocInput,
  CreatePocResult,
  DocumentFindingInput,
  DocumentFindingResult,
} from './types';
import { CreatePocSchema, DocumentFindingSchema } from './types';

const execAsync = promisify(exec);

/** Retry configuration for overloaded errors */
const RETRY_CONFIG = {
  maxRetries: 5,
  initialDelayMs: 1000,
  maxDelayMs: 60000,
  backoffMultiplier: 2,
};

/** Check if error is an overloaded/rate limit error */
function isOverloadedError(error: any): boolean {
  const message = error?.message?.toLowerCase() || '';
  const status = error?.status || error?.statusCode;

  return (
    status === 429 ||
    status === 529 ||
    status === 503 ||
    message.includes('overloaded') ||
    message.includes('rate limit') ||
    message.includes('too many requests') ||
    message.includes('capacity') ||
    message.includes('temporarily unavailable')
  );
}

/** Sleep for a specified duration */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export interface RunVulnerabilityTestAgentOpts {
  input: VulnerabilityTestInput;
  model: AIModel;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
  toolOverride?: {
    execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
  };
}

/**
 * Runs a specialized vulnerability testing agent for a specific vulnerability class.
 *
 * This agent:
 * 1. Receives vulnerability-class-specific guidance in its system prompt
 * 2. Uses a POC-driven approach to test for vulnerabilities
 * 3. Creates and executes bash scripts to confirm exploitation
 * 4. Documents confirmed findings with evidence
 */
export async function runVulnerabilityTestAgent(
  opts: RunVulnerabilityTestAgentOpts
): Promise<VulnerabilityTestResult> {
  const { input, model, onStepFinish, abortSignal, toolOverride } = opts;
  const {
    target,
    objective,
    vulnerabilityClass,
    authenticationInfo,
    authenticationInstructions,
    outcomeGuidance,
    session,
  } = input;

  // Create logger
  const logger = new Logger(
    { rootPath: session.rootPath, logsPath: session.logsPath } as Session,
    `vulnerability-test-${vulnerabilityClass}.log`
  );

  logger.info(`Starting ${vulnerabilityClass} testing for ${target}`);
  logger.info(`Objective: ${objective}`);

  // Ensure pocs directory exists
  const pocsPath = session.pocsPath;
  if (!existsSync(pocsPath)) {
    mkdirSync(pocsPath, { recursive: true });
  }

  // Create minimal session-like object for tools
  const sessionForTools = {
    id: session.id,
    rootPath: session.rootPath,
    findingsPath: session.findingsPath,
    logsPath: session.logsPath,
    target,
  } as Session;

  // Create base tools
  const { execute_command, http_request, fuzz_endpoint } = createPentestTools(
    sessionForTools,
    undefined,
    toolOverride
  );

  // Track results
  const pocPaths: string[] = [];
  const findingPaths: string[] = [];
  let testingSummary = '';
  let pocAttempts = 0;
  const MAX_POC_ATTEMPTS = 3;

  // Tool: create_poc - Creates and tests POC scripts
  const create_poc = tool({
    name: 'create_poc',
    description: `Create and test a Proof-of-Concept script.

**Primarily use bash scripts** - they are automatically executed and tested.

This tool:
1. Creates the POC file in the pocs/ directory
2. For bash: Makes executable (chmod +x) and runs it
3. Returns execution output for analysis
4. **Deletes the file if execution fails**

Use this iteratively:
- Create POC → Review output → If failed, create improved version
- Max ${MAX_POC_ATTEMPTS} attempts before giving up

**Bash POC requirements:**
- Start with #!/bin/bash
- Include rate limiting
- Exit 0 on success, 1 on failure
- Clear success/failure indicators`,
    inputSchema: CreatePocSchema,
    execute: async (poc: CreatePocInput): Promise<CreatePocResult> => {
      pocAttempts++;
      logger.info(`POC attempt ${pocAttempts}/${MAX_POC_ATTEMPTS}: ${poc.pocName}`);

      try {
        const extension = poc.pocType === 'bash' ? '.sh' : '.html';
        const sanitizedName = poc.pocName
          .toLowerCase()
          .replace(/[^a-z0-9_-]/g, '_')
          .replace(/^poc_/, '');

        const filename = `poc_${sanitizedName}_${vulnerabilityClass}${extension}`;
        const pocPath = join(pocsPath, filename);
        const relativePocPath = `pocs/${filename}`;

        let pocContent = poc.pocContent.trim();

        // Add bash header if needed
        if (poc.pocType === 'bash') {
          if (!pocContent.startsWith('#!')) {
            pocContent = '#!/bin/bash\n' + pocContent;
          }
          if (!pocContent.includes('# POC:')) {
            const header = `#!/bin/bash
# POC: ${poc.description}
# Target: ${target}
# Vulnerability Class: ${vulnerabilityClass}
# Created: ${new Date().toISOString()}

`;
            pocContent = header + pocContent.replace(/^#!\/bin\/bash\s*\n/, '');
          }
        }

        // Write POC
        writeFileSync(pocPath, pocContent);

        // Execute if bash
        if (poc.pocType === 'bash') {
          chmodSync(pocPath, 0o755);

          try {
            const { stdout, stderr } = await execAsync(
              `cd ${session.rootPath} && ./${relativePocPath}`,
              { timeout: 30000, maxBuffer: 1024 * 1024 }
            );

            logger.info(`POC executed successfully: ${filename}`);
            pocPaths.push(relativePocPath);

            return {
              success: true,
              pocPath: relativePocPath,
              execution: {
                success: true,
                exitCode: 0,
                stdout: stdout || '(no output)',
                stderr: stderr || '(no errors)',
              },
              message: `POC created and executed successfully at: ${relativePocPath}

**Execution Output:**
STDOUT:
\`\`\`
${stdout || '(no output)'}
\`\`\`

STDERR:
\`\`\`
${stderr || '(no errors)'}
\`\`\`

If the output confirms the vulnerability, call document_finding with pocPath: "${relativePocPath}"`,
            };
          } catch (execError: any) {
            // Delete failed POC
            logger.info(`POC execution failed, deleting: ${filename}`);
            try {
              unlinkSync(pocPath);
            } catch (e) {}

            return {
              success: false,
              error: execError.message,
              execution: {
                success: false,
                exitCode: execError.code || 1,
                stdout: execError.stdout || '',
                stderr: execError.stderr || execError.message,
              },
              message: `POC execution FAILED (attempt ${pocAttempts}/${MAX_POC_ATTEMPTS})

**Error:** ${execError.message}

STDOUT:
\`\`\`
${execError.stdout || '(none)'}
\`\`\`

STDERR:
\`\`\`
${execError.stderr || execError.message}
\`\`\`

${pocAttempts < MAX_POC_ATTEMPTS
  ? 'Analyze the error and create an improved POC with a different name.'
  : 'Max attempts reached. Consider if the vulnerability exists or try a different approach.'}`,
            };
          }
        } else {
          // HTML POC - no execution
          pocPaths.push(relativePocPath);
          return {
            success: true,
            pocPath: relativePocPath,
            message: `HTML POC created at: ${relativePocPath}

To test:
1. Open in browser: file://${pocPath}
2. Or serve: cd ${pocsPath} && python3 -m http.server 8000

After manual verification, call document_finding with pocPath: "${relativePocPath}"`,
          };
        }
      } catch (error: any) {
        logger.error(`POC creation error: ${error.message}`);
        return {
          success: false,
          error: error.message,
          message: `Failed to create POC: ${error.message}`,
        };
      }
    },
  });

  // Tool: document_finding - Records confirmed vulnerabilities
  const document_finding = tool({
    name: 'document_finding',
    description: `Document a confirmed vulnerability with evidence.

**Requirements:**
- POC must exist at the specified pocPath
- Include evidence from POC execution output
- Only call AFTER confirming exploitation via create_poc

This tool:
1. Validates POC exists
2. Checks for duplicate findings
3. Saves finding JSON to session
4. Updates findings summary`,
    inputSchema: DocumentFindingSchema,
    execute: async (finding: DocumentFindingInput): Promise<DocumentFindingResult> => {
      logger.info(`Documenting finding: ${finding.title}`);

      try {
        // Validate POC exists
        const fullPocPath = join(session.rootPath, finding.pocPath);
        if (!existsSync(fullPocPath)) {
          return {
            success: false,
            error: 'POC_NOT_FOUND',
            message: `POC not found at: ${finding.pocPath}. Create POC first using create_poc tool.`,
          };
        }

        // Check for duplicates
        const existingFindings = loadExistingFindings(session.findingsPath);
        const isDuplicate = existingFindings.some(
          (f) =>
            f.title.toLowerCase() === finding.title.toLowerCase() ||
            (f.endpoint === finding.endpoint &&
              f.description.toLowerCase().includes(vulnerabilityClass))
        );

        if (isDuplicate) {
          logger.info(`Duplicate finding detected: ${finding.title}`);
          return {
            success: false,
            error: 'DUPLICATE',
            message: `Duplicate finding - already documented. Continue testing for other vulnerabilities.`,
          };
        }

        // Create finding with metadata
        const timestamp = new Date().toISOString();
        const id = nanoid(6);

        const findingWithMeta = {
          ...finding,
          timestamp,
          id,
          sessionId: session.id,
          target,
          vulnerabilityClass,
        };

        // Save finding
        const safeTitle = finding.title
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '')
          .substring(0, 50);

        const filename = `${timestamp.split('T')[0]}-${safeTitle}.json`;
        const filepath = join(session.findingsPath, filename);

        writeFileSync(filepath, JSON.stringify(findingWithMeta, null, 2));
        findingPaths.push(filepath);

        // Update summary
        const summaryPath = join(session.rootPath, 'findings-summary.md');
        const summaryEntry = `- [${finding.severity}] ${finding.title} - \`findings/${filename}\` - POC: \`${finding.pocPath}\`\n`;

        try {
          appendFileSync(summaryPath, summaryEntry);
        } catch (e) {
          const header = `# Findings Summary\n\n**Target:** ${target}\n**Session:** ${session.id}\n\n## Findings\n\n`;
          writeFileSync(summaryPath, header + summaryEntry);
        }

        logger.info(`Finding documented: ${filename}`);

        return {
          success: true,
          findingPath: filepath,
          message: `Finding documented: [${finding.severity}] ${finding.title}

Saved to: findings/${filename}
POC: ${finding.pocPath}

Continue testing for additional vulnerabilities.`,
        };
      } catch (error: any) {
        logger.error(`Document finding error: ${error.message}`);
        return {
          success: false,
          error: error.message,
          message: `Failed to document finding: ${error.message}`,
        };
      }
    },
  });

  // Tool: complete_testing - Signals testing completion
  const complete_testing = tool({
    name: 'complete_testing',
    description: `Signal that vulnerability testing is complete.

Call this when:
- You've found and documented vulnerabilities
- You've exhausted testing approaches (max POC attempts)
- The target doesn't appear vulnerable to this class

Provide a summary of what was tested and found.`,
    inputSchema: z.object({
      summary: z.string().describe('Summary of testing performed and results'),
      vulnerabilitiesFound: z.boolean().describe('Whether any vulnerabilities were confirmed'),
    }),
    execute: async (result) => {
      testingSummary = result.summary;
      logger.info(`Testing complete: ${result.vulnerabilitiesFound ? 'Vulnerabilities found' : 'No vulnerabilities found'}`);
      return {
        success: true,
        message: 'Testing session completed.',
      };
    },
  });

  // Build system prompt with vulnerability-specific guidance
  const systemPrompt = buildSystemPrompt(vulnerabilityClass, outcomeGuidance);

  // Build user prompt with target context
  const userPrompt = buildUserPrompt({
    target,
    objective,
    vulnerabilityClass,
    authenticationInfo,
    authenticationInstructions,
  });

  // Run the agent with retry logic for overloaded errors
  let attempt = 0;
  let lastError: any = null;

  while (attempt < RETRY_CONFIG.maxRetries) {
    attempt++;

    try {
      logger.info(`Running vulnerability test agent (attempt ${attempt}/${RETRY_CONFIG.maxRetries})`);

      const streamResult = streamResponse({
        prompt: userPrompt,
        system: systemPrompt,
        model,
        tools: {
          execute_command,
          http_request,
          create_poc,
          document_finding,
          complete_testing,
          fuzz_endpoint
        },
        onStepFinish,
        stopWhen: hasToolCall('complete_testing'),
        abortSignal,
        silent: true,
      });

      // Consume the stream, checking for overloaded errors
      for await (const chunk of streamResult.fullStream) {
        if (chunk.type === 'error') {
          const error = (chunk as any).error;
          if (isOverloadedError(error)) {
            throw error;
          }
        }
      }

      logger.info(`Testing finished. Findings: ${findingPaths.length}`);

      // Save agent messages
      try {
        const response = await streamResult.response;
        if (response.messages && response.messages.length > 0) {
          const sanitizedTarget = target.replace(/[^a-z0-9]/gi, '-').substring(0, 30);
          const savedPath = saveAgentMessages(
            session.rootPath,
            `vuln-test-${vulnerabilityClass}-${sanitizedTarget}`,
            response.messages,
            {
              target,
              objective,
              vulnerabilityClass,
              findingsCount: findingPaths.length,
              pocAttempts,
            }
          );
          logger.info(`Vulnerability test agent messages saved to: ${savedPath}`);
        }
      } catch (e: any) {
        logger.error(`Failed to save vulnerability test agent messages: ${e.message}`);
      }

      return {
        vulnerabilitiesFound: findingPaths.length > 0,
        findingsCount: findingPaths.length,
        pocPaths,
        findingPaths,
        summary: testingSummary || `Tested ${target} for ${getVulnerabilityClassName(vulnerabilityClass)}`,
      };
    } catch (error: any) {
      lastError = error;

      // Check if it's an overloaded error that should trigger retry
      if (isOverloadedError(error) && attempt < RETRY_CONFIG.maxRetries) {
        const delay = Math.min(
          RETRY_CONFIG.initialDelayMs * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt - 1),
          RETRY_CONFIG.maxDelayMs
        );

        logger.info(`API overloaded, retrying in ${delay / 1000}s... (attempt ${attempt}/${RETRY_CONFIG.maxRetries})`);
        await sleep(delay);
        continue;
      }

      // Not an overloaded error or max retries reached - throw
      throw error;
    }
  }

  // Max retries exhausted
  logger.error(`Vulnerability test agent failed after ${RETRY_CONFIG.maxRetries} attempts: ${lastError?.message}`);
  throw new Error(`Max retries (${RETRY_CONFIG.maxRetries}) exhausted. Last error: ${lastError?.message}`);
}

/**
 * Build user prompt with target context
 */
function buildUserPrompt(params: {
  target: string;
  objective: string;
  vulnerabilityClass: VulnerabilityClass;
  authenticationInfo?: VulnerabilityTestInput['authenticationInfo'];
  authenticationInstructions?: string;
}): string {
  const { target, objective, vulnerabilityClass, authenticationInfo, authenticationInstructions } = params;

  let prompt = `
# Testing Assignment

**Target:** ${target}
**Objective:** ${objective}
**Vulnerability Class:** ${getVulnerabilityClassName(vulnerabilityClass)}

## Your Task

Test the target for ${getVulnerabilityClassName(vulnerabilityClass)} vulnerabilities using the POC-driven workflow:

1. **Analyze** the target endpoint
2. **Create POC** using create_poc tool
3. **Review output** - if successful, document; if failed, iterate
4. **Document findings** with document_finding
5. **Complete** by calling complete_testing

`;

  if (authenticationInstructions) {
    prompt += `
## Authentication Instructions

${authenticationInstructions}

**Include this authentication in all POC scripts.**
`;
  }

  if (authenticationInfo) {
    prompt += `
## Authentication Details

- Method: ${authenticationInfo.method}
- Details: ${authenticationInfo.details}
${authenticationInfo.cookies ? `- Cookies: ${authenticationInfo.cookies}` : ''}
${authenticationInfo.headers ? `- Headers: ${authenticationInfo.headers}` : ''}
`;
  }

  prompt += `
## Guidelines

- Use rate limiting in all POC scripts
- Max 3 POC attempts before moving on
- Only document confirmed vulnerabilities
- Call complete_testing when finished

Begin testing now.
`;

  return prompt.trim();
}

/**
 * Load existing findings from the findings directory
 */
function loadExistingFindings(findingsPath: string): any[] {
  if (!existsSync(findingsPath)) {
    return [];
  }

  const files = readdirSync(findingsPath).filter((f) => f.endsWith('.json'));
  return files.map((f) => {
    try {
      return JSON.parse(readFileSync(join(findingsPath, f), 'utf-8'));
    } catch {
      return null;
    }
  }).filter(Boolean);
}
