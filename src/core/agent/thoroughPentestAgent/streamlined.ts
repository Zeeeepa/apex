/**
 * Streamlined Thorough Pentest Agent
 *
 * 1. AttackSurfaceAgent -> discovers targets
 * 2. PentestOrchestrator -> spawns MetaVulnerabilityTestAgents in parallel (cognitive loop inspired by CyberAutoAgent)
 * 3. ReportGeneratorAgent -> generates final report
 *
 * Key patterns:
 * - Confidence-driven reasoning (HYPOTHESIS → VALIDATION)
 * - Plans as external working memory with checkpoint protocol
 * - Meta-prompting for runtime optimization
 * - Direct-first economics (minimal steps to objective)
 * - Parallel agent spawning per (target, vulnClass) pair
 */

import type { AIModel } from '../../ai';
import { Session } from '../../session';
import { runAgent as runAttackSurfaceAgent } from '../attackSurfaceAgent/agent';
import {
  runPentestOrchestrator,
  type SubAgentSpawnInfo,
  type SubAgentStreamEvent,
} from '../orchestrator/orchestrator';
import { generatePentestReport } from '../reportGeneratorAgent';
import type { AttackSurfaceAnalysisResults, PentestTarget } from '../attackSurfaceAgent/types';
import type { MetaVulnerabilityTestResult } from '../metaTestingAgent';
import { Logger } from '../logger';
import { join } from 'path';
import { readFileSync, existsSync, writeFileSync, mkdirSync } from 'fs';
import type {
  ExecuteCommandOpts,
  ExecuteCommandResult,
  HttpRequestOpts,
  HttpRequestResult,
} from '../tools';
import type { StreamTextOnStepFinishCallback, ToolSet } from 'ai';
import { generateRandomName } from '../../../util/name';

function saveAgentMessages(
  sessionRootPath: string,
  agentName: string,
  messages: any[],
  metadata?: Record<string, any>
): string {
  const subagentsDir = join(sessionRootPath, 'subagents');
  if (!existsSync(subagentsDir)) {
    mkdirSync(subagentsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const sanitizedName = agentName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
  const filename = `${sanitizedName}-${timestamp}.json`;
  const filepath = join(subagentsDir, filename);

  const data = {
    agentName,
    timestamp: new Date().toISOString(),
    ...metadata,
    messages,
  };

  writeFileSync(filepath, JSON.stringify(data, null, 2));
  return filepath;
}

export interface StreamlinedPentestInput {
  target: string;

  model: AIModel;

  session?: Session.SessionInfo;

  sessionConfig?: {
    outcomeGuidance?: string;
    scopeConstraints?: any;
    authenticationInstructions?: string;
    remoteSandboxUrl?: string;
  };

  onProgress?: (status: StreamlinedPentestProgress) => void;

  onDiscoveryStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;

  onDiscoveryStream?: (chunk: any) => void;

  onPentestAgentSpawn?: (info: SubAgentSpawnInfo) => void;

  onPentestAgentStream?: (event: SubAgentStreamEvent) => void;

  onPentestAgentComplete?: (agentId: string, result: MetaVulnerabilityTestResult) => void;

  abortSignal?: AbortSignal;

  /** Tool overrides for sandboxed execution */
  toolOverride?: {
    execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
  };
}

export interface StreamlinedPentestProgress {
  phase: 'discovery' | 'testing' | 'reporting' | 'complete';
  message: string;
  targetsDiscovered?: number;
  targetsCompleted?: number;
  tasksCompleted?: number;
  totalTasks?: number;
  activeAgents?: number;
  findingsCount?: number;
}

export interface StreamlinedPentestResult {
  success: boolean;
  session: Session.SessionInfo;
  targets: PentestTarget[];
  totalFindings: number;
  reportPath?: string;
  error?: string;
}

/**
 * Run a streamlined thorough penetration test.
 *
 * Flow:
 * 1. AttackSurfaceAgent discovers targets and objectives
 * 2. MetaTestingAgent tests all targets using cognitive loop (HYPOTHESIS → VALIDATION)
 * 3. ReportGeneratorAgent generates the final report
 */
export async function runStreamlinedPentest(
  input: StreamlinedPentestInput
): Promise<StreamlinedPentestResult> {
  const {
    target,
    model,
    sessionConfig,
    onProgress,
    onDiscoveryStepFinish,
    onDiscoveryStream,
    onPentestAgentSpawn,
    onPentestAgentStream,
    onPentestAgentComplete,
    abortSignal,
    toolOverride,
  } = input;

  // Create session
  const session = input.session || await Session.create({
    targets: [target],
    name: generateRandomName(),
    ...sessionConfig
  });

  const logger = new Logger(session, 'streamlined-pentest.log');
  logger.info(`Starting streamlined pentest for ${target}`);

  const reportProgress = (status: StreamlinedPentestProgress) => {
    logger.info(`[${status.phase}] ${status.message}`);
    onProgress?.(status);
  };

  try {
    // Phase 1: Attack Surface Discovery
    reportProgress({
      phase: 'discovery',
      message: `Discovering attack surface for ${target}`,
    });

    const { targets, discoveryError } = await runDiscoveryPhase({
      target,
      model,
      session,
      abortSignal,
      toolOverride,
      logger,
      onProgress: reportProgress,
      onStepFinish: onDiscoveryStepFinish,
      onStream: onDiscoveryStream,
    });

    if (discoveryError) {
      return {
        success: false,
        session,
        targets: [],
        totalFindings: 0,
        error: discoveryError,
      };
    }

    if (targets.length === 0) {
      reportProgress({
        phase: 'complete',
        message: 'No targets discovered. Attack surface analysis returned no testable targets.',
        targetsDiscovered: 0,
      });

      return {
        success: true,
        session,
        targets: [],
        totalFindings: 0,
      };
    }

    reportProgress({
      phase: 'discovery',
      message: `Discovered ${targets.length} targets`,
      targetsDiscovered: targets.length,
    });

    // Phase 2: Vulnerability Testing via PentestOrchestrator (spawns MetaVulnerabilityTestAgents)
    reportProgress({
      phase: 'testing',
      message: `Starting parallel vulnerability testing for ${targets.length} targets (cognitive loop active)`,
      targetsDiscovered: targets.length,
    });

    const pentestResult = await runPentestOrchestrator({
      targets,
      model,
      session,
      sessionConfig,
      abortSignal,
      toolOverride,
      onProgress: (status) => {
        reportProgress({
          phase: 'testing',
          message: status.message,
          targetsDiscovered: targets.length,
          targetsCompleted: status.targetsCompleted,
          tasksCompleted: status.tasksCompleted,
          totalTasks: status.totalTasks,
          activeAgents: status.activeAgents,
          findingsCount: status.findingsCount,
        });
      },
      onAgentSpawn: onPentestAgentSpawn,
      onAgentStream: onPentestAgentStream,
      onAgentComplete: onPentestAgentComplete,
    });

    logger.info(`Vulnerability testing complete. Total findings: ${pentestResult.totalFindings}`);

    // Phase 3: Report Generation
    reportProgress({
      phase: 'reporting',
      message: 'Generating final report',
      targetsDiscovered: targets.length,
      targetsCompleted: targets.length,
      findingsCount: pentestResult.totalFindings,
    });

    const reportResult = await generatePentestReport({
      sessionRootPath: session.rootPath,
      sessionId: session.id,
      target,
      startTime: session.time.created.toString(),
      reportTitle: `Penetration Test Report - ${target}`,
      includeMethodology: true,
    });

    reportProgress({
      phase: 'complete',
      message: `Pentest complete. ${pentestResult.totalFindings} findings documented.`,
      targetsDiscovered: targets.length,
      targetsCompleted: targets.length,
      findingsCount: pentestResult.totalFindings,
    });

    return {
      success: true,
      session,
      targets,
      totalFindings: pentestResult.totalFindings,
      reportPath: reportResult.reportPath,
    };
  } catch (error: any) {
    logger.error(`Streamlined pentest error: ${error.message}`);
    return {
      success: false,
      session,
      targets: [],
      totalFindings: 0,
      error: error.message,
    };
  }
}

/** Retry configuration for overloaded errors */
const RETRY_CONFIG = {
  maxRetries: 5,
  initialDelayMs: 1000,
  maxDelayMs: 60000,
  backoffMultiplier: 2,
};

/** Check if error is an overloaded/rate limit error */
function isOverloadedError(error: any): boolean {
  const message = error?.message?.toLowerCase() || '';
  const status = error?.status || error?.statusCode;

  return (
    status === 429 ||
    status === 529 ||
    status === 503 ||
    message.includes('overloaded') ||
    message.includes('rate limit') ||
    message.includes('too many requests') ||
    message.includes('capacity') ||
    message.includes('temporarily unavailable')
  );
}

/** Sleep for a specified duration */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Run the discovery phase using AttackSurfaceAgent
 * Includes logging and exponential retry for overloaded errors
 */
async function runDiscoveryPhase(params: {
  target: string;
  model: AIModel;
  session: Session.SessionInfo;
  abortSignal?: AbortSignal;
  toolOverride?: any;
  logger: Logger;
  onProgress?: (status: StreamlinedPentestProgress) => void;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  onStream?: (chunk: any) => void;
}): Promise<{ targets: PentestTarget[]; discoveryError?: string }> {
  const { target, model, session, abortSignal, toolOverride, logger, onProgress, onStepFinish, onStream } = params;

  let attempt = 0;
  let lastError: any = null;

  while (attempt < RETRY_CONFIG.maxRetries) {
    attempt++;

    try {
      logger.info(`Running attack surface analysis for ${target} (attempt ${attempt}/${RETRY_CONFIG.maxRetries})`);

      if (attempt > 1) {
        onProgress?.({
          phase: 'discovery',
          message: `Retrying attack surface analysis (attempt ${attempt}/${RETRY_CONFIG.maxRetries})`,
        });
      }

      let stepCount = 0;
      let toolCallCount = 0;

      const { streamResult } = await runAttackSurfaceAgent({
        target,
        objective: 'Comprehensive attack surface discovery and target identification',
        model,
        session,
        abortSignal,
        toolOverride,
        onStepFinish: (step) => {
          stepCount++;

          // Count tool calls for summary
          if (step.toolCalls && step.toolCalls.length > 0) {
            toolCallCount += step.toolCalls.length;
          }

          // Log text output (trimmed) - tool calls are logged from stream
          if (step.text && step.text.trim()) {
            const trimmedText = step.text.trim().substring(0, 200);
            if (trimmedText.length > 0) {
              logger.info(`[Step ${stepCount}] ${trimmedText}${step.text.length > 200 ? '...' : ''}`);
            }
          }

          // Forward to caller for token tracking and UI updates
          onStepFinish?.(step);
        },
      });

      // Consume the stream with detailed logging
      let chunkCount = 0;
      for await (const chunk of streamResult.fullStream) {
        chunkCount++;

        // Forward stream chunks to caller for TUI rendering
        onStream?.(chunk);

        // Log tool calls from stream (more reliable for args)
        if (chunk.type === 'tool-call') {
          const toolName = chunk.toolName || 'unknown';
          let args: Record<string, any> = {};

          // Parse args from chunk - AI SDK uses 'input' not 'args'
          const rawInput = (chunk as any).input;
          try {
            if (typeof rawInput === 'string') {
              args = JSON.parse(rawInput);
            } else if (rawInput && typeof rawInput === 'object') {
              args = rawInput as Record<string, any>;
            }
          } catch (e) {
            args = {};
          }

          // Format description based on tool type
          let description = '';
          try {
            if (toolName === 'http_request') {
              description = `${args.method || 'GET'} ${args.url || ''}`;
            } else if (toolName === 'execute_command') {
              description = (args.command || '').substring(0, 80);
            } else if (toolName === 'document_asset') {
              description = `${args.assetType || ''}: ${args.assetName || ''}`;
            } else if (toolName === 'create_attack_surface_report') {
              description = `${args.targets?.length || 0} targets`;
            } else if (toolName === 'authenticate_and_maintain_session') {
              description = `${args.loginUrl || ''} as ${args.username || ''}`;
            } else if (toolName === 'extract_javascript_endpoints') {
              description = args.url || '';
            } else if (toolName === 'crawl_authenticated_area') {
              description = `${args.startUrl || ''} depth=${args.maxDepth || 3}`;
            } else {
              const argsStr = JSON.stringify(args);
              description = argsStr.length > 80 ? argsStr.substring(0, 80) + '...' : argsStr;
            }
          } catch (e) {
            description = JSON.stringify(rawInput || {}).substring(0, 80);
          }

          const logMsg = `[Tool] ${toolName}: ${description}`;
          logger.info(logMsg);
          console.log(`[discovery] ${logMsg}`);

          onProgress?.({
            phase: 'discovery',
            message: `[${toolName}] ${description}`,
          });
        } else if (chunk.type === 'tool-result') {
          const toolName = chunk.toolName || 'unknown';
          let resultSummary = '';
          // AI SDK uses 'output' not 'result'
          const rawOutput = (chunk as any).output;
          try {
            if (typeof rawOutput === 'object' && rawOutput !== null) {
              const r = rawOutput as any;
              if (r.message) {
                resultSummary = String(r.message).substring(0, 100);
              } else if (r.success !== undefined) {
                resultSummary = `success=${r.success}`;
              } else {
                resultSummary = JSON.stringify(r).substring(0, 100);
              }
            } else {
              resultSummary = String(rawOutput).substring(0, 100);
            }
          } catch (e) {
            resultSummary = '(error parsing result)';
          }

          logger.info(`[Result] ${toolName}: ${resultSummary}`);
        } else if (chunk.type === 'error') {
          const error = (chunk as any).error;
          logger.error(`Stream error: ${error?.message || 'Unknown error'}`);

          // Check if it's an overloaded error - if so, throw to trigger retry
          if (isOverloadedError(error)) {
            throw error;
          }
        }
      }

      logger.info(`Attack surface analysis completed. ${toolCallCount} tool calls, ${stepCount} steps.`);

      // Save agent messages
      try {
        const response = await streamResult.response;
        if (response.messages && response.messages.length > 0) {
          const savedPath = saveAgentMessages(
            session.rootPath,
            'attack-surface-agent',
            response.messages,
            {
              target,
              toolCallCount,
              stepCount,
            }
          );
          logger.info(`Attack surface agent messages saved to: ${savedPath}`);
        }
      } catch (e: any) {
        logger.error(`Failed to save attack surface agent messages: ${e.message}`);
      }

      // Read results
      const resultsPath = join(session.rootPath, 'attack-surface-results.json');

      if (!existsSync(resultsPath)) {
        logger.info('No attack surface results file found');
        return { targets: [] };
      }

      const resultsData = readFileSync(resultsPath, 'utf-8');
      const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

      logger.info(`Attack surface discovered ${results.targets?.length || 0} targets`);

      return {
        targets: results.targets || [],
      };
    } catch (error: any) {
      lastError = error;

      // Check if it's an overloaded error that should trigger retry
      if (isOverloadedError(error) && attempt < RETRY_CONFIG.maxRetries) {
        const delay = Math.min(
          RETRY_CONFIG.initialDelayMs * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt - 1),
          RETRY_CONFIG.maxDelayMs
        );

        logger.info(`API overloaded, retrying in ${delay / 1000}s... (attempt ${attempt}/${RETRY_CONFIG.maxRetries})`);

        onProgress?.({
          phase: 'discovery',
          message: `API overloaded, retrying in ${delay / 1000}s...`,
        });

        await sleep(delay);
        continue;
      }

      // Not an overloaded error or max retries reached
      logger.error(`Discovery phase error: ${error.message}`);
      return {
        targets: [],
        discoveryError: error.message,
      };
    }
  }

  // Max retries exhausted
  logger.error(`Discovery phase failed after ${RETRY_CONFIG.maxRetries} attempts: ${lastError?.message}`);
  return {
    targets: [],
    discoveryError: `Max retries (${RETRY_CONFIG.maxRetries}) exhausted. Last error: ${lastError?.message}`,
  };
}
