import {
  stepCountIs,
  type StreamTextResult,
  type ToolSet,
  type StreamTextOnStepFinishCallback,
  tool,
  type ModelMessage,
  hasToolCall,
} from "ai";
import { streamResponse, type AIModel } from "../../ai";
import { SYSTEM } from "./prompts";
import { Session } from "../../session";
import { z } from "zod";
import { join } from "path";
import { readFileSync, existsSync, writeFileSync, copyFileSync, readdirSync, mkdirSync } from "fs";
import { runAgent as runAttackSurfaceAgent } from "../attackSurfaceAgent/agent";
import { runAgent as runPentestAgent } from "../pentestAgent/agent";
import type { AttackSurfaceAnalysisResults } from "../attackSurfaceAgent/types";
import { Messages } from "../../messages";
import { Logger } from "../logger";
import { detectOSAndEnhancePrompt } from "../utils";
import pLimit from "p-limit";
import type { Message, ToolMessage } from "../../messages/types";
import { Identifier } from "../../id/id";

export interface SubagentSpawnInfo {
  id: string;
  name: string;
  type: "attack-surface" | "pentest";
  target: string;
  args?: Record<string, any>;
}

export interface RunAgentProps {
  target: string;
  authenticationInstructions?: string;
  model: AIModel;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
  session?: Session.ExecutionSession;
  sessionConfig?: any;
  onSubagentSpawn?: (info: SubagentSpawnInfo) => void;
  onSubagentMessage?: (subagentId: string, message: Message) => void;
  onSubagentComplete?: (subagentId: string, success: boolean) => void;
  toolOverride?: {
    execute_command?: (opts: any) => Promise<any>;
    http_request?: (opts: any) => Promise<any>;
    create_poc?: (opts: any) => Promise<any>;
  };
}

export interface RunAgentResult extends StreamTextResult<ToolSet, never> {
  session: Session.ExecutionSession;
}

export async function runAgent(opts: RunAgentProps): Promise<{
  streamResult: RunAgentResult;
  session: Session.ExecutionSession;
}> {
  const {
    target,
    authenticationInstructions,
    model,
    onStepFinish,
    abortSignal,
    sessionConfig,
    onSubagentSpawn,
    onSubagentMessage,
    onSubagentComplete,
    session: sessionProp,
    toolOverride,
  } = opts;
  const session = sessionProp || await Session.createExecution({
    target,
    config: sessionConfig,
  });

  // Read scope constraints from session config
  const scopeConstraints = session.config?.scopeConstraints;

  const logger = new Logger(session);

  // Create a new session for this thorough pentest
  logger.log(`Created thorough pentest session: ${session.id}`);
  logger.log(`Session path: ${session.rootPath}`);

  // Create orchestrator-specific tools
  const tools = createOrchestratorTools(
    session,
    model,
    abortSignal,
    onSubagentSpawn,
    onSubagentMessage,
    onSubagentComplete,
    logger,
    toolOverride
  );

  // Build the enhanced prompt with target context
  const enhancedPrompt = `
TARGET: ${target}

Session Information:
- Session ID: ${session.id}
- Session Path: ${session.rootPath}

${authenticationInstructions
?
`<authentication_instructions>
${authenticationInstructions}
</auhtentication_instructions>${`\n`}`
: ''
}
You are the ORCHESTRATOR agent for a comprehensive penetration testing engagement.

Your mission:
1. First, run the attack surface agent to discover all assets and identify high-value targets (pass <authentication_instructions/> to this agent so that it may authenticate to perform recon)
2. Review the attack surface analysis results
3. Strategically spawn pentest agents for high-value targets identified
4. Monitor and coordinate all sub-agent activities
5. Generate a comprehensive final report combining all findings

Begin by using the get_attack_surface tool to map the complete attack surface of the target.
`.trim();

  const systemPrompt = detectOSAndEnhancePrompt(SYSTEM);

  const streamResult = streamResponse({
    prompt: enhancedPrompt,
    system: systemPrompt,
    model,
    tools,
    stopWhen: stepCountIs(10000),
    toolChoice: "auto",
    onStepFinish,
    abortSignal,
  });

  // Attach the session directly to the stream result object
  (streamResult as any).session = session;

  return { streamResult: streamResult as RunAgentResult, session };
}

/**
 * Create tools specific to the orchestrator agent
 */
function createOrchestratorTools(
  session: Session.ExecutionSession,
  model: AIModel,
  abortSignal?: AbortSignal,
  onSubagentSpawn?: (info: SubagentSpawnInfo) => void,
  onSubagentMessage?: (subagentId: string, message: Message) => void,
  onSubagentComplete?: (subagentId: string, success: boolean) => void,
  logger?: Logger,
  toolOverride?: {
    execute_command?: (opts: any) => Promise<any>;
    http_request?: (opts: any) => Promise<any>;
    create_poc?: (opts: any) => Promise<any>;
  }
) {
  // Tool to run attack surface agent
  const getAttackSurface = tool({
    name: "get_attack_surface",
    description: `Run the attack surface analysis agent to discover all assets and identify targets.
    
This tool spawns a specialized reconnaissance agent that will:
- Map all domains, subdomains, IPs, and services
- Identify web applications, APIs, and cloud resources
- Categorize assets by type and risk level
- Identify high-value targets for deep penetration testing
- Return structured results with recommended testing objectives

The agent operates autonomously and will return comprehensive results including:
- Complete asset inventory
- High-value targets with suggested objectives
- Key findings from reconnaissance
- Recommended testing priorities

Use this as the FIRST step in your thorough penetration test.`,
    inputSchema: z.object({
      target: z.string().describe("The target to analyze (domain, IP, or URL)"),
      objective: z
        .string()
        .describe("Specific focus areas for attack surface analysis"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call").optional(),
    }),
    execute: async ({ target, objective }) => {
      try {
        logger?.log(
          `[Orchestrator] Spawning attack surface agent for: ${target}`
        );

        // Run the attack surface agent (auth instructions are in session.config)
        const { streamResult: result, session: attackSession } = await runAttackSurfaceAgent({
          session,
          target,
          objective,
          model,
          abortSignal,
          toolOverride,
        });

        const subagentId = `attack-surface-${attackSession.id}`;
        const allMessages: Message[] = [];
        let currentAssistantText = "";

        // Notify about subagent spawn
        if (onSubagentSpawn) {
          onSubagentSpawn({
            id: subagentId,
            name: `Attack Surface Analysis: ${target}`,
            type: "attack-surface",
            args: {
              target,
              objective,
            },
            target,
          });
        }

        // Add initial user message
        const initialMessage: Message = {
          sessionId: session.id,
          id: Identifier.create("message", true),
          role: "user",
          content: `Target: ${target}\nObjective: ${objective}`,
          createdAt: new Date(),
        };
        allMessages.push(initialMessage);

        // Send initial message to UI
        if (onSubagentMessage) {
          onSubagentMessage(subagentId, initialMessage);
        }

        // Consume the stream and capture messages
        for await (const delta of result.fullStream) {
          if (delta.type === "text-delta") {
            currentAssistantText += delta.text;
            const lastMessage = allMessages[allMessages.length - 1];

            if (lastMessage && lastMessage.role === "assistant") {
              const updatedMessage: Message = {
                ...lastMessage,
                content: currentAssistantText,
              };
              allMessages[allMessages.length - 1] = updatedMessage;
              if (onSubagentMessage) {
                onSubagentMessage(subagentId, updatedMessage);
              }
            } else {
              const newMessage: Message = {
                sessionId: session.id,
                id: Identifier.create("message", true),
                role: "assistant",
                content: currentAssistantText,
                createdAt: new Date(),
              };
              allMessages.push(newMessage);
              if (onSubagentMessage) {
                onSubagentMessage(subagentId, newMessage);
              }
            }
          } else if (delta.type === "tool-call") {
            if (currentAssistantText) {
              currentAssistantText = "";
            }

            const toolMessage: Message = {
              sessionId: session.id,
              id: Identifier.create("message", true),
              role: "tool",
              status: "pending",
              toolCallId: delta.toolCallId,
              content:
                delta.input.toolCallDescription || `Calling ${delta.toolName}`,
              args: delta.input,
              toolName: delta.toolName,
              createdAt: new Date(),
            };
            allMessages.push(toolMessage);
            if (onSubagentMessage) {
              onSubagentMessage(subagentId, toolMessage);
            }
          } else if (delta.type === "tool-result") {
            const existingToolMessageIndex = allMessages.findIndex(
              (msg) =>
                msg.role === "tool" &&
                (msg as ToolMessage).toolCallId === delta.toolCallId
            );

            if (existingToolMessageIndex !== -1) {
              const existingMessage = allMessages[
                existingToolMessageIndex
              ] as ToolMessage;
              const updatedMessage: ToolMessage = {
                ...existingMessage,
                status: "completed",
                content: delta.input.toolCallDescription
                  ? `✓ ${delta.input.toolCallDescription}`
                  : `✓ Tool ${delta.toolName}`,
              };
              allMessages[existingToolMessageIndex] = updatedMessage;
              if (onSubagentMessage) {
                onSubagentMessage(subagentId, updatedMessage);
              }
            }
          }
        }

        // Notify completion
        if (onSubagentComplete) {
          onSubagentComplete(subagentId, true);
        }

        // Save subagent messages to orchestrator session
        Messages.saveSubagentMessages(session, subagentId, allMessages);

        // Save subagent metadata
        const subagentMetadata = {
          type: "attack-surface",
          subagentId,
          target,
          objective,
          sessionId: attackSession.id,
          sessionPath: attackSession.rootPath,
          startTime: new Date().toISOString(),
          endTime: new Date().toISOString(),
        };

        writeFileSync(
          join(session.rootPath, "subagents", subagentId, "metadata.json"),
          JSON.stringify(subagentMetadata, null, 2)
        );

        // Read the results file
        const resultsPath = join(
          attackSession.rootPath,
          "attack-surface-results.json"
        );

        if (existsSync(resultsPath)) {
          const resultsData = readFileSync(resultsPath, "utf-8");
          const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

          return {
            success: true,
            sessionId: attackSession.id,
            sessionPath: attackSession.rootPath,
            subagentId,
            resultsPath,
            summary: results.summary,
            targets: results.targets,
            message: `Attack surface analysis complete. Discovered ${results.summary.totalAssets} assets with ${results.summary.highValueTargets} high-value targets identified for penetration testing. Subagent messages saved to subagents/${subagentId}/`,
          };
        } else {
          // Notify failure
          if (onSubagentComplete) {
            onSubagentComplete(subagentId, false);
          }
          logger?.error(
            `[Orchestrator] Attack surface agent did not produce results file`
          );

          return {
            success: false,
            sessionId: attackSession.id,
            sessionPath: attackSession.rootPath,
            subagentId,
            error: "Attack surface agent did not produce results file",
            message:
              "The attack surface agent completed but did not generate the expected results. Check the session logs.",
          };
        }
      } catch (error: any) {
        // Notify failure if subagent was spawned
        logger?.error(
          `[Orchestrator] Failed to run attack surface agent: ${error.message}`
        );
        if (onSubagentComplete) {
          const subagentId = `attack-surface-failed`;
          onSubagentComplete(subagentId, false);
        }

        return {
          success: false,
          error: error.message,
          message: `Failed to run attack surface agent: ${error.message}`,
        };
      }
    },
  });

  // Tool to run pentest agents for specific targets
  const runPentestAgents = tool({
    name: "run_pentest_agents",
    description: `Spawn penetration testing agents for specific targets.
    
This tool runs specialized penetration testing agents that will:
- Perform deep security testing on specific targets
- Test for common web vulnerabilities (SQLi, XSS, CSRF, etc.)
- Analyze authentication and authorization mechanisms
- Check for misconfigurations and exposures
- Generate detailed findings with severity ratings
- Create comprehensive penetration testing reports

Each agent operates autonomously and performs thorough black-box testing.

Use this tool AFTER reviewing attack surface results to test high-value targets.
You can spawn multiple agents in parallel - they will run concurrently.`,
    inputSchema: z.object({
      targets: z
        .array(
          z.object({
            target: z
              .string()
              .describe(
                "The specific URL to pentest against (URL, IP, or domain)"
              ),
            objective: z
              .string()
              .describe(
                "Specific penetration testing objective for this target"
              ),
            authenticationInfo: z
              .object({
                method: z.string().describe("Authentication method (e.g., 'cookie-based session', 'JWT Bearer token', 'API key')"),
                details: z.string().describe("How to authenticate (e.g., 'POST to /login with username/password')"),
                credentials: z.string().optional().describe("Credentials if available (e.g., 'username:password')"),
                cookies: z.string().optional().describe("Session cookie value if available"),
                headers: z.string().optional().describe("Required authentication headers if applicable"),
              })
              .optional()
              .describe("Authentication information for this target (required if target needs authentication)"),
          })
        )
        .describe("Array of ALL potentially vulnerable targets to pentest."),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call").optional(),
    }),
    execute: async ({ targets }) => {
      try {
        logger?.log(
          `[Orchestrator] Spawning ${targets.length} pentest agents with max 20 concurrent...`
        );

        const MAX_CONCURRENT = 20;
        const allResults: any[] = [];

        // Split targets into batches of 20
        for (let batchStart = 0; batchStart < targets.length; batchStart += MAX_CONCURRENT) {
          const batchEnd = Math.min(batchStart + MAX_CONCURRENT, targets.length);
          const batch = targets.slice(batchStart, batchEnd);

          logger?.log(
            `[Orchestrator] Starting batch ${Math.floor(batchStart / MAX_CONCURRENT) + 1}: agents ${batchStart + 1}-${batchEnd} of ${targets.length}`
          );

          // PHASE 1: Start ALL agents in this batch immediately (no rate limiting)
          const agentInfos = await Promise.all(batch.map(async (targetInfo, batchIndex) => {
            const globalIndex = batchStart + batchIndex;

            // Format authentication instructions from target auth info
            const authInstructions = targetInfo.authenticationInfo
              ? `AUTHENTICATION REQUIRED:
Method: ${targetInfo.authenticationInfo.method}
Details: ${targetInfo.authenticationInfo.details}
${targetInfo.authenticationInfo.credentials ? `Credentials: ${targetInfo.authenticationInfo.credentials}` : ''}
${targetInfo.authenticationInfo.cookies ? `Session Cookie: ${targetInfo.authenticationInfo.cookies}` : ''}
${targetInfo.authenticationInfo.headers ? `Required Headers: ${targetInfo.authenticationInfo.headers}` : ''}

**CRITICAL**: Include this authentication in ALL http_request calls and POCs you generate.`
              : undefined;

            // Create a session with authentication instructions in config
            const pentestSessionConfig = {
              ...session.config,
              authenticationInstructions: authInstructions,
            };

            // This returns immediately - just creates a stream object
            const { streamResult: result, session: pentestSession } = await runPentestAgent({
              session: undefined, // Let it create a new session
              target: targetInfo.target,
              objective: targetInfo.objective,
              model,
              abortSignal,
              toolOverride,
              sessionConfig: pentestSessionConfig,
            });

            const subagentId = `pentest-${globalIndex + 1}-${pentestSession.id}`;

            // Notify spawn immediately
            if (onSubagentSpawn) {
              onSubagentSpawn({
                id: subagentId,
                name: `Pentest ${globalIndex + 1}: ${targetInfo.target}`,
                type: "pentest",
                args: {
                  target: targetInfo.target,
                  objective: targetInfo.objective,
                },
                target: targetInfo.target,
              });
            }

            return {
              targetInfo,
              globalIndex,
              streamResult: result,
              subagentId,
              startTime: new Date().toISOString(),
            };
          }));

          logger?.log(
            `[Orchestrator] Started ${agentInfos.length} agents in batch, now consuming streams in parallel...`
          );

          // PHASE 2: Consume all streams in parallel (no p-limit needed)
          const consumptionPromises = agentInfos.map(async (info) => {
            const { targetInfo, globalIndex, streamResult, subagentId, startTime } = info;
            const allMessages: Message[] = [];
            let currentAssistantText = "";

            try {
              // Add initial user message
              const initialMessage: Message = {
                sessionId: session.id,
                id: Identifier.create("message", true),
                role: "user",
                content: `Target: ${targetInfo.target}\nObjective: ${targetInfo.objective}`,
                createdAt: new Date(),
              };
              allMessages.push(initialMessage);

              if (onSubagentMessage) {
                onSubagentMessage(subagentId, initialMessage);
              }

              // Consume stream (this is truly parallel now)
              for await (const delta of streamResult.fullStream) {
                if (delta.type === "text-delta") {
                  currentAssistantText += delta.text;
                  const lastMessage = allMessages[allMessages.length - 1];

                  if (lastMessage && lastMessage.role === "assistant") {
                    const updatedMessage: Message = {
                      ...lastMessage,
                      content: currentAssistantText,
                    };
                    allMessages[allMessages.length - 1] = updatedMessage;
                    if (onSubagentMessage) {
                      onSubagentMessage(subagentId, updatedMessage);
                    }
                  } else {
                    const newMessage: Message = {
                      sessionId: session.id,
                      id: Identifier.create("message", true),
                      role: "assistant",
                      content: currentAssistantText,
                      createdAt: new Date(),
                    };
                    allMessages.push(newMessage);
                    if (onSubagentMessage) {
                      onSubagentMessage(subagentId, newMessage);
                    }
                  }
                } else if (delta.type === "tool-call") {
                  if (currentAssistantText) {
                    currentAssistantText = "";
                  }

                  const toolMessage: Message = {
                    sessionId: session.id,
                    id: Identifier.create("message", true),
                    role: "tool",
                    status: "pending",
                    toolCallId: delta.toolCallId,
                    content:
                      delta.input.toolCallDescription ||
                      `Calling ${delta.toolName}`,
                    args: delta.input,
                    toolName: delta.toolName,
                    createdAt: new Date(),
                  };
                  allMessages.push(toolMessage);
                  if (onSubagentMessage) {
                    onSubagentMessage(subagentId, toolMessage);
                  }
                } else if (delta.type === "tool-result") {
                  const existingToolMessageIndex = allMessages.findIndex(
                    (msg) =>
                      msg.role === "tool" &&
                      (msg as ToolMessage).toolCallId === delta.toolCallId
                  );

                  if (existingToolMessageIndex !== -1) {
                    const existingMessage = allMessages[
                      existingToolMessageIndex
                    ] as ToolMessage;
                    const updatedMessage: ToolMessage = {
                      ...existingMessage,
                      status: "completed",
                      content: delta.input.toolCallDescription
                        ? `✓ ${delta.input.toolCallDescription}`
                        : `✓ Tool ${delta.toolName}`,
                    };
                    allMessages[existingToolMessageIndex] = updatedMessage;
                    if (onSubagentMessage) {
                      onSubagentMessage(subagentId, updatedMessage);
                    }
                  }
                }
              }

              const endTime = new Date().toISOString();

              // Notify completion
              if (onSubagentComplete) {
                onSubagentComplete(subagentId, true);
              }

              // Save subagent messages
              Messages.saveSubagentMessages(session, subagentId, allMessages);

              // Save metadata
              const subagentMetadata = {
                type: "pentest",
                subagentId,
                target: targetInfo.target,
                objective: targetInfo.objective,
                sessionId: streamResult.session.id,
                sessionPath: streamResult.session.rootPath,
                startTime,
                endTime,
                agentIndex: globalIndex + 1,
              };

              writeFileSync(
                join(
                  session.rootPath,
                  "subagents",
                  subagentId,
                  "metadata.json"
                ),
                JSON.stringify(subagentMetadata, null, 2)
              );

              return {
                target: targetInfo.target,
                success: true,
                sessionId: streamResult.session.id,
                sessionPath: streamResult.session.rootPath,
                subagentId,
              };
            } catch (error: any) {
              logger?.error(
                `[Orchestrator] Pentest agent ${globalIndex + 1} failed: ${error.message}`
              );

              if (onSubagentComplete) {
                onSubagentComplete(subagentId, false);
              }

              return {
                target: targetInfo.target,
                success: false,
                error: error.message,
              };
            }
          });

          // Wait for all agents in this batch to complete
          const batchResults = await Promise.all(consumptionPromises);
          allResults.push(...batchResults);

          logger?.log(
            `[Orchestrator] Batch ${Math.floor(batchStart / MAX_CONCURRENT) + 1} complete: ${batchResults.filter(r => r.success).length}/${batchResults.length} successful`
          );
        }

        const successful = allResults.filter((r) => r.success).length;
        const failed = allResults.filter((r) => !r.success).length;

        return {
          success: true,
          totalAgents: targets.length,
          successful,
          failed,
          results: allResults,
          message: `Launched ${targets.length} pentest agents in batches of ${MAX_CONCURRENT}. ${successful} completed successfully${
            failed > 0 ? `, ${failed} failed` : ""
          }. All subagent messages saved to subagents/ directory.`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to spawn pentest agents: ${error.message}`,
        };
      }
    },
  });

  // Tool to read attack surface results
  const readAttackSurfaceResults = tool({
    name: "read_attack_surface_results",
    description: `Read the structured results from a completed attack surface analysis.
    
Use this after running get_attack_surface to review:
- Complete asset inventory
- High-value targets with objectives
- Key findings and exposures
- Recommended testing priorities

This helps you decide which targets to send to pentest agents.`,
    inputSchema: z.object({
      sessionPath: z
        .string()
        .describe("Path to the attack surface agent session"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call").optional(),
    }),
    execute: async ({ sessionPath }) => {
      try {
        const resultsPath = join(sessionPath, "attack-surface-results.json");

        if (!existsSync(resultsPath)) {
          return {
            success: false,
            error: "Results file not found",
            message: `No results file found at ${resultsPath}`,
          };
        }

        const resultsData = readFileSync(resultsPath, "utf-8");
        const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

        return {
          success: true,
          results,
          message: `Loaded attack surface results: ${results.summary.totalAssets} assets, ${results.summary.highValueTargets} high-value targets`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to read results: ${error.message}`,
        };
      }
    },
  });

  // Tool to generate final orchestration report
  const generateFinalReport = tool({
    name: "generate_final_report",
    description: `Generate the final comprehensive report for the entire thorough penetration test.
    
This creates a master report that combines:
- Attack surface analysis findings
- All pentest agent findings
- Overall risk assessment
- Prioritized recommendations
- Executive summary

Use this as the FINAL step after all agents have completed.`,
    inputSchema: z.object({
      executiveSummary: z
        .string()
        .describe("High-level executive summary of the entire engagement"),
      attackSurfaceSessionPath: z
        .string()
        .describe("Path to attack surface agent session"),
      pentestSessionPaths: z
        .array(z.string())
        .describe("Paths to all pentest agent sessions"),
      overallRiskAssessment: z
        .string()
        .describe("Overall risk assessment across all targets"),
      keyFindings:
        z.preprocess((val) => Array.isArray(val) ? val : [val],
        z.array(z.string())
          .describe("Most critical findings across all agents"),
      ),
      recommendations: z
        .string()
        .describe("Comprehensive recommendations for remediation"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call").optional(),
    }),
    execute: async ({
      executiveSummary,
      attackSurfaceSessionPath,
      pentestSessionPaths,
      overallRiskAssessment,
      keyFindings,
      recommendations,
    }) => {
      try {
        // Consolidate findings from all pentest sessions to orchestrator session
        const orchestratorFindingsDir = join(session.rootPath, "findings");
        const orchestratorPocsDir = join(session.rootPath, "pocs");

        mkdirSync(orchestratorFindingsDir, { recursive: true });
        mkdirSync(orchestratorPocsDir, { recursive: true });

        let totalFindings = 0;
        let totalPocs = 0;

        for (const pentestSessionPath of pentestSessionPaths) {
          // Copy findings JSON files
          const findingsDir = join(pentestSessionPath, "findings");
          if (existsSync(findingsDir)) {
            const files = readdirSync(findingsDir);
            for (const file of files) {
              if (file.endsWith('.json')) {
                const sourcePath = join(findingsDir, file);
                const destPath = join(orchestratorFindingsDir, file);
                copyFileSync(sourcePath, destPath);
                totalFindings++;
              }
            }
          }

          // Copy POC files
          const pocsDir = join(pentestSessionPath, "pocs");
          if (existsSync(pocsDir)) {
            const files = readdirSync(pocsDir);
            for (const file of files) {
              const sourcePath = join(pocsDir, file);
              const destPath = join(orchestratorPocsDir, file);
              // Handle duplicate filenames - skip if already exists
              if (!existsSync(destPath)) {
                copyFileSync(sourcePath, destPath);
                totalPocs++;
              }
            }
          }
        }

        console.log(`✓ Consolidated ${totalFindings} findings and ${totalPocs} POCs from ${pentestSessionPaths.length} pentest agents`);

        // This would aggregate all reports - simplified for now
        const report = `# Comprehensive Penetration Testing Report

**Session ID:** ${session.id}
**Target:** ${session.target}
**Objective:** ${session.objective}

## Executive Summary

${executiveSummary}

## Overall Risk Assessment

${overallRiskAssessment}

## Key Findings

${keyFindings.map((finding, idx) => `${idx + 1}. ${finding}`).join("\n")}

## Recommendations

${recommendations}

## Sub-Agent Sessions

### Attack Surface Analysis
- Session: ${attackSurfaceSessionPath}

### Penetration Testing Sessions
${pentestSessionPaths.map((path, idx) => `${idx + 1}. ${path}`).join("\n")}

---

*This report aggregates findings from ${
          pentestSessionPaths.length + 1
        } autonomous security testing agents.*
`;

        const reportPath = join(
          session.rootPath,
          "comprehensive-pentest-report.md"
        );
        writeFileSync(reportPath, report);

        return {
          success: true,
          reportPath,
          findingsConsolidated: totalFindings,
          pocsConsolidated: totalPocs,
          message: `Comprehensive report generated at ${reportPath}. Consolidated ${totalFindings} findings and ${totalPocs} POCs from ${pentestSessionPaths.length} pentest agents.`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to generate report: ${error.message}`,
        };
      }
    },
  });

  return {
    get_attack_surface: getAttackSurface,
    run_pentest_agents: runPentestAgents,
    read_attack_surface_results: readAttackSurfaceResults,
    generate_final_report: generateFinalReport,
  };
}
