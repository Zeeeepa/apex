import { streamResponse, type AIModel } from '../../ai';
import { type AIAuthConfig } from '../../ai/utils';
import { Session } from '../../session';
import { createPentestTools, type ExecuteCommandOpts, type ExecuteCommandResult, type HttpRequestOpts, type HttpRequestResult } from '../tools';
import { createPocTool, createDocumentFindingTool } from '../metaTestingAgent/pocTools';
import { META_TESTING_SYSTEM_PROMPT } from '../metaTestingAgent/prompts/execution';
import { Logger } from '../logger';
import type { StreamTextResult, ToolSet, StreamTextOnStepFinishCallback } from 'ai';
import { hasToolCall } from 'ai';

export interface RunAgentInput {
  model: AIModel;
  objective: string;
  target: string;
  session: Session.SessionInfo;
  messages?: any[];
  authConfig?: AIAuthConfig;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
  toolOverride?: {
    execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
    create_poc?: (opts: any) => Promise<any>;
  };
}

export function runAgent(opts: RunAgentInput): { streamResult: StreamTextResult<ToolSet, never> } {
  const { model, objective, target, session, authConfig, onStepFinish, abortSignal, toolOverride } = opts;

  // Create logger for tools
  const logger = new Logger(session, 'pentest-agent.log');

  // Create pentest tools with session context
  const baseTools = createPentestTools(session, model, toolOverride);

  // Add POC and finding tools (they require logger and target)
  const { create_poc } = createPocTool(session, logger, toolOverride);
  const { document_finding } = createDocumentFindingTool(session, logger, target);

  const tools = { ...baseTools, create_poc, document_finding };

  // Build prompts
  const systemPrompt = META_TESTING_SYSTEM_PROMPT;
  const userPrompt = `# Testing Assignment

## Target
- **URL:** ${target}
- **Objective:** ${objective}

## Instructions
1. Analyze the target for security vulnerabilities
2. Use available tools to test for common vulnerability classes (SQLi, XSS, IDOR, etc.)
3. Create POC scripts to demonstrate any confirmed vulnerabilities
4. Document findings with clear evidence and remediation steps
`;

  const streamResult = streamResponse({
    prompt: userPrompt,
    system: systemPrompt,
    model,
    tools,
    onStepFinish,
    abortSignal,
    authConfig,
    stopWhen: hasToolCall('document_finding'),
    silent: true,
  });

  return { streamResult };
}
