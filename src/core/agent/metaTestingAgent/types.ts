import { z } from 'zod';
import type { Session } from '../../session';
import type { PentestTarget } from '../attackSurfaceAgent/types';
import type {
  ExecuteCommandOpts,
  ExecuteCommandResult,
  HttpRequestOpts,
  HttpRequestResult,
} from '../tools';

/**
 * Vulnerability class types (shared with VulnerabilityTestAgent for compatibility)
 */
export type VulnerabilityClass =
  | 'sqli'              // SQL/NoSQL Injection
  | 'idor'              // IDOR/Authorization/Access Control
  | 'xss'               // Cross-Site Scripting
  | 'command-injection' // Command/OS Injection
  | 'generic';          // SSRF, XXE, SSTI, CSRF, Path Traversal, etc.

/**
 * Phase status in the pentest plan
 */
export type PhaseStatus = 'active' | 'pending' | 'done' | 'blocked' | 'partial_failure';

/**
 * A single phase in the pentest plan
 */
export interface Phase {
  /** Phase identifier */
  id: number;
  /** Human-readable phase title */
  title: string;
  /** Current status of this phase */
  status: PhaseStatus;
  /** Success criteria for this phase */
  criteria: string;
  /** Number of attempts made in this phase */
  attempts: number;
}

/**
 * Strategic pentest plan stored in session
 */
export interface PentestPlan {
  /** Main objective for the pentest */
  objective: string;
  /** Primary target URL/host */
  target: string;
  /** Current active phase (1-indexed) */
  current_phase: number;
  /** Total number of phases */
  total_phases: number;
  /** Estimated budget utilization (0-100%) */
  budget_used: number;
  /** All phases in the plan */
  phases: Phase[];
  /** Timestamp when plan was created */
  created_at: string;
  /** Timestamp when plan was last updated */
  updated_at: string;
}

/**
 * Record of an approach that was tried (for meta-prompting)
 */
export interface Adaptation {
  /** Description of the approach tried */
  approach: string;
  /** Whether it worked or not */
  worked: boolean;
  /** Specific constraint learned (e.g., "WAF blocks <script>") */
  constraint_learned?: string;
  /** Target/endpoint this was tried on */
  target?: string;
  /** Timestamp */
  timestamp: number;
}

/**
 * Current cognitive state during testing
 */
export interface CognitiveState {
  /** Current confidence level (0-100) */
  confidence: number;
  /** Current hypothesis being tested */
  current_hypothesis: string;
  /** Evidence collected so far */
  evidence: string[];
  /** Constraints learned from failures */
  constraints_learned: string[];
  /** Number of steps taken */
  step_count: number;
  /** Current budget utilization estimate */
  budget_used: number;
}

/**
 * Prompt optimization data generated by meta-prompting
 */
export interface PromptOptimization {
  /** Approaches that failed - should be removed from tactics */
  remove_tactics: string[];
  /** Approaches that worked - should be emphasized */
  emphasize_tactics: string[];
  /** Known constraints/blockers (WAF rules, etc.) */
  constraints: string[];
  /** Timestamp of optimization */
  timestamp: string;
}

/**
 * POC types supported
 */
export type PocType = 'bash' | 'python';

/**
 * Zod schema for create_poc tool input
 */
export const CreatePocSchema = z.object({
  pocName: z.string().describe('Descriptive name for the POC (e.g., sqli_union_extract)'),
  pocType: z.enum(['bash', 'python']).describe('Script type - bash preferred, python for complex scenarios'),
  pocContent: z.string().describe('Complete script content'),
  description: z.string().describe('What vulnerability this POC demonstrates'),
});

export type CreatePocInput = z.infer<typeof CreatePocSchema>;

/**
 * Result from create_poc tool
 */
export interface CreatePocResult {
  success: boolean;
  pocPath?: string;
  execution?: {
    success: boolean;
    exitCode?: number;
    stdout?: string;
    stderr?: string;
  };
  error?: string;
  message: string;
}

/**
 * Zod schema for document_finding tool input
 */
export const DocumentFindingSchema = z.object({
  title: z.string().describe('Clear, concise finding title'),
  severity: z.preprocess(
    (val) => {
      if (typeof val === 'string') {
        const upper = val.toUpperCase();
        if (upper.includes('CRITICAL')) return 'CRITICAL';
        if (upper.includes('HIGH')) return 'HIGH';
        if (upper.includes('MEDIUM')) return 'MEDIUM';
        if (upper.includes('LOW')) return 'LOW';
      }
      return val;
    },
    z.enum(['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'])
  ),
  description: z.string().describe('Detailed technical description'),
  impact: z.string().describe('Potential impact if exploited'),
  evidence: z.string().describe('Evidence/proof of vulnerability including POC output'),
  endpoint: z.string().describe('Full URL endpoint (e.g., https://example.com/api/endpoint)'),
  pocPath: z.string().describe('Relative path to POC script (e.g., pocs/poc_sqli_login.sh)'),
  remediation: z.string().describe('Steps to fix the vulnerability'),
  references: z.string().optional().describe('CVE, CWE, or related references'),
});

export type DocumentFindingInput = z.infer<typeof DocumentFindingSchema>;

/**
 * Result from document_finding tool
 */
export interface DocumentFindingResult {
  success: boolean;
  findingPath?: string;
  error?: string;
  message: string;
}

/**
 * Zod schema for store_plan tool input
 */
export const StorePlanSchema = z.object({
  objective: z.string().describe('Main objective for the pentest'),
  target: z.string().describe('Primary target URL/host'),
  current_phase: z.number().describe('Current active phase (1-indexed)'),
  total_phases: z.number().describe('Total number of phases'),
  budget_used: z.number().min(0).max(100).describe('Estimated budget utilization (0-100%)'),
  phases: z.array(z.object({
    id: z.number(),
    title: z.string(),
    status: z.enum(['active', 'pending', 'done', 'blocked', 'partial_failure']),
    criteria: z.string(),
    attempts: z.number().default(0),
  })).describe('All phases in the plan'),
});

export type StorePlanInput = z.infer<typeof StorePlanSchema>;

/**
 * Zod schema for store_adaptation tool input
 */
export const StoreAdaptationSchema = z.object({
  approach: z.string().describe('Description of the approach tried'),
  worked: z.boolean().describe('Whether it worked or not'),
  constraint_learned: z.string().optional().describe('Specific constraint learned (e.g., "WAF blocks script tags")'),
  target: z.string().optional().describe('Target/endpoint this was tried on'),
});

export type StoreAdaptationInput = z.infer<typeof StoreAdaptationSchema>;

/**
 * Session info passed to MetaTestingAgent
 */
export interface MetaTestingSessionInfo {
  id: string;
  rootPath: string;
  findingsPath: string;
  logsPath: string;
  pocsPath: string;
}

/**
 * Authentication information for testing
 */
export interface AuthenticationInfo {
  method: string;        // e.g., "cookie-based session", "bearer token"
  details: string;       // How to authenticate
  credentials?: string;  // username:password
  cookies?: string;      // Session cookies
  headers?: string;      // Auth headers
}

/**
 * Input for MetaTestingAgent
 */
export interface MetaTestingAgentInput {
  /** Targets from AttackSurfaceAgent */
  targets: PentestTarget[];

  /** AI model to use */
  model: any; // AIModel type

  /** Session for this pentest run */
  session: Session.ExecutionSession;

  /** Session configuration */
  sessionConfig?: {
    outcomeGuidance?: string;
    scopeConstraints?: any;
    authenticationInstructions?: string;
  };

  /** Progress callback */
  onProgress?: (status: MetaTestingProgressStatus) => void;

  /** Abort signal */
  abortSignal?: AbortSignal;

  /** Tool overrides for sandboxed execution */
  toolOverride?: {
    execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
  };
}

/**
 * Progress status during meta testing
 */
export interface MetaTestingProgressStatus {
  phase: 'planning' | 'testing' | 'optimizing' | 'complete';
  message: string;
  currentTarget?: string;
  currentPhase?: number;
  totalPhases?: number;
  confidence?: number;
  findingsCount?: number;
  budgetUsed?: number;
}

/**
 * Result from MetaTestingAgent
 */
export interface MetaTestingAgentResult {
  success: boolean;
  session: Session.ExecutionSession;
  totalFindings: number;
  pocPaths: string[];
  findingPaths: string[];
  summary: string;
  cognitiveState?: CognitiveState;
  error?: string;
}
