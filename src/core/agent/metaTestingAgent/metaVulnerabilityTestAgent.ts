/**
 * MetaVulnerabilityTestAgent
 *
 * A cognitive-loop-driven vulnerability testing agent designed to be spawned
 * in parallel by the PentestOrchestrator. Each instance tests ONE (target, vulnerabilityClass) pair.
 *
 * Key patterns from CyberAutoAgent:
 * - Confidence-driven reasoning (HYPOTHESIS → VALIDATION)
 * - Plans as external working memory with checkpoints
 * - Meta-prompting for runtime optimization
 * - Direct-first economics
 */

import { tool, hasToolCall, type StreamTextOnStepFinishCallback, type ToolSet } from 'ai';
import { z } from 'zod';
import { streamResponse, type AIModel } from '../../ai';
import {
  createPentestTools,
  type ExecuteCommandOpts,
  type ExecuteCommandResult,
  type HttpRequestOpts,
  type HttpRequestResult,
} from '../tools';
import { Logger } from '../logger';
import type { Session } from '../sessions';
import { DEFAULT_OUTCOME_GUIDANCE } from '../sessions';
import { join } from 'path';
import { existsSync, mkdirSync, writeFileSync, readdirSync, readFileSync } from 'fs';

// Import tools and types
import type { MetaTestingSessionInfo, CognitiveState } from './types';
import { createPocTool, createDocumentFindingTool } from './pocTools';
import { createPlanMemoryTools, loadPlan, loadAdaptations } from './planMemory';
import { createPromptOptimizerTool } from './promptOptimizer';
import {
  buildSystemPrompt as buildVulnClassPrompt,
  getVulnerabilityClassName,
} from '../vulnerabilityTestAgent/prompts';
import type { VulnerabilityClass } from '../vulnerabilityTestAgent/types';

/**
 * Retry configuration for API overload errors
 */
const RETRY_CONFIG = {
  maxRetries: 5,
  initialDelayMs: 1000,
  maxDelayMs: 60000,
  backoffMultiplier: 2,
};

function isOverloadedError(error: any): boolean {
  const message = error?.message?.toLowerCase() || '';
  const status = error?.status || error?.statusCode;
  return (
    status === 429 ||
    status === 529 ||
    status === 503 ||
    message.includes('overloaded') ||
    message.includes('rate limit') ||
    message.includes('too many requests') ||
    message.includes('capacity') ||
    message.includes('temporarily unavailable')
  );
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function saveAgentMessages(
  sessionRootPath: string,
  agentName: string,
  messages: any[],
  metadata?: Record<string, any>
): string {
  const subagentsDir = join(sessionRootPath, 'subagents');
  if (!existsSync(subagentsDir)) {
    mkdirSync(subagentsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const sanitizedName = agentName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
  const filename = `${sanitizedName}-${timestamp}.json`;
  const filepath = join(subagentsDir, filename);

  writeFileSync(filepath, JSON.stringify({
    agentName,
    timestamp: new Date().toISOString(),
    ...metadata,
    messages,
  }, null, 2));

  return filepath;
}

/**
 * Input for MetaVulnerabilityTestAgent
 */
export interface MetaVulnerabilityTestInput {
  target: string;
  objective: string;
  vulnerabilityClass: VulnerabilityClass;
  authenticationInfo?: {
    method: string;
    details: string;
    credentials?: string;
    cookies?: string;
    headers?: string;
  };
  authenticationInstructions?: string;
  outcomeGuidance: string;
  session: {
    id: string;
    rootPath: string;
    findingsPath: string;
    logsPath: string;
    pocsPath: string;
  };
}

/**
 * Result from MetaVulnerabilityTestAgent
 */
export interface MetaVulnerabilityTestResult {
  vulnerabilitiesFound: boolean;
  findingsCount: number;
  pocPaths: string[];
  findingPaths: string[];
  summary: string;
  error?: string;
}

/**
 * Cognitive loop system prompt addition
 */
const COGNITIVE_LOOP_PROMPT = `
## Cognitive Loop (MANDATORY)

### Before EVERY tool call, state:
\`\`\`
HYPOTHESIS:
- Technique: [what I'm trying] (attempt N of method, attempt M of approach)
- Confidence: [0-100%] because [reasoning]
- Expected: if TRUE → [outcome], if FALSE → [pivot plan]
\`\`\`

### After EVERY tool result, state:
\`\`\`
VALIDATION:
- Outcome: [YES/NO + evidence]
- Constraint learned: [specific, not vague]
- Confidence: BEFORE [X%] → AFTER [Y%]
- Decision: [pivot (<50%) | iterate (50-80%) | exploit (>80%)]
\`\`\`

## Confidence Thresholds
- **>80%**: Direct exploitation
- **50-80%**: Hypothesis testing
- **<50%**: MUST pivot to different approach

## Direct-First Economics
Prefer shortest path to objective:
- SQLi found? → UNION extract (3 steps) NOT enumerate schema (20 steps)
- Creds found? → Login (1 step) NOT crack (60 steps)

## Adaptation Tracking
After significant attempts:
- Call store_adaptation with worked=true/false
- Include constraint_learned if you discovered a blocker
- At 3+ failures, call optimize_prompt to update guidance
`;

/**
 * Run the MetaVulnerabilityTestAgent
 *
 * Tests a single (target, vulnerabilityClass) pair using cognitive loop reasoning.
 */
export async function runMetaVulnerabilityTestAgent(
  opts: {
    input: MetaVulnerabilityTestInput;
    model: AIModel;
    onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
    abortSignal?: AbortSignal;
    toolOverride?: {
      execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
      http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
    };
  }
): Promise<MetaVulnerabilityTestResult> {
  const { input, model, onStepFinish, abortSignal, toolOverride } = opts;
  const {
    target,
    objective,
    vulnerabilityClass,
    authenticationInfo,
    authenticationInstructions,
    outcomeGuidance,
    session,
  } = input;

  const logger = new Logger(
    { rootPath: session.rootPath, logsPath: session.logsPath } as Session,
    `meta-vuln-test-${vulnerabilityClass}.log`
  );

  logger.info(`Starting MetaVulnerabilityTestAgent for ${target} [${vulnerabilityClass}]`);
  logger.info(`Objective: ${objective}`);

  // Ensure pocs directory exists
  if (!existsSync(session.pocsPath)) {
    mkdirSync(session.pocsPath, { recursive: true });
  }

  // Create session info for tools
  const sessionInfo: MetaTestingSessionInfo = {
    id: session.id,
    rootPath: session.rootPath,
    findingsPath: session.findingsPath,
    logsPath: session.logsPath,
    pocsPath: session.pocsPath,
  };

  // Get base pentest tools
  const sessionForTools = {
    id: session.id,
    rootPath: session.rootPath,
    findingsPath: session.findingsPath,
    logsPath: session.logsPath,
    target,
  } as Session;

  const { execute_command, http_request, fuzz_endpoint } = createPentestTools(
    sessionForTools,
    undefined,
    toolOverride
  );

  // Create cognitive loop tools
  const { create_poc, pocPaths } = createPocTool(sessionInfo, logger, toolOverride);
  const { document_finding, findingPaths } = createDocumentFindingTool(sessionInfo, logger, target);
  const { store_plan, get_plan, store_adaptation } = createPlanMemoryTools(sessionInfo, logger);
  const { optimize_prompt } = createPromptOptimizerTool(sessionInfo, logger);

  // Completion tool
  let testingSummary = '';
  const complete_testing = tool({
    description: `Signal that vulnerability testing is complete.

Call when:
- Vulnerability found and documented
- Max attempts exhausted
- Target not vulnerable to this class
- Confidence dropped and pivoted through all approaches`,
    inputSchema: z.object({
      summary: z.string().describe('Summary of testing and results'),
      vulnerabilitiesFound: z.boolean().describe('Whether vulnerabilities were confirmed'),
    }),
    execute: async (result) => {
      testingSummary = result.summary;
      logger.info(`Testing complete: ${result.vulnerabilitiesFound ? 'Found' : 'None'}`);
      return { success: true, message: 'Testing completed.' };
    },
  });

  // Combine all tools
  const tools = {
    execute_command,
    http_request,
    fuzz_endpoint,
    create_poc,
    document_finding,
    store_plan,
    get_plan,
    store_adaptation,
    optimize_prompt,
    complete_testing,
  };

  // Build system prompt: vulnerability-specific + cognitive loop
  const vulnClassPrompt = buildVulnClassPrompt(vulnerabilityClass, outcomeGuidance);
  const systemPrompt = vulnClassPrompt + '\n\n---\n' + COGNITIVE_LOOP_PROMPT;

  // Build user prompt
  const userPrompt = buildUserPrompt({
    target,
    objective,
    vulnerabilityClass,
    authenticationInfo,
    authenticationInstructions,
  });

  // Run with retry logic
  let attempt = 0;
  let lastError: any = null;

  while (attempt < RETRY_CONFIG.maxRetries) {
    attempt++;

    try {
      logger.info(`Running agent (attempt ${attempt}/${RETRY_CONFIG.maxRetries})`);

      const streamResult = streamResponse({
        prompt: userPrompt,
        system: systemPrompt,
        model,
        tools,
        onStepFinish,
        stopWhen: hasToolCall('complete_testing'),
        abortSignal,
        silent: true,
      });

      // Consume stream
      for await (const chunk of streamResult.fullStream) {
        if (chunk.type === 'error') {
          const error = (chunk as any).error;
          if (isOverloadedError(error)) {
            throw error;
          }
        }
      }

      logger.info(`Testing finished. Findings: ${findingPaths.length}`);

      // Save messages
      try {
        const response = await streamResult.response;
        if (response.messages?.length > 0) {
          const sanitizedTarget = target.replace(/[^a-z0-9]/gi, '-').substring(0, 30);
          saveAgentMessages(
            session.rootPath,
            `meta-vuln-${vulnerabilityClass}-${sanitizedTarget}`,
            response.messages,
            { target, objective, vulnerabilityClass, findingsCount: findingPaths.length }
          );
        }
      } catch (e: any) {
        logger.error(`Failed to save messages: ${e.message}`);
      }

      return {
        vulnerabilitiesFound: findingPaths.length > 0,
        findingsCount: findingPaths.length,
        pocPaths,
        findingPaths,
        summary: testingSummary || `Tested ${target} for ${getVulnerabilityClassName(vulnerabilityClass)}`,
      };

    } catch (error: any) {
      lastError = error;

      if (isOverloadedError(error) && attempt < RETRY_CONFIG.maxRetries) {
        const delay = Math.min(
          RETRY_CONFIG.initialDelayMs * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt - 1),
          RETRY_CONFIG.maxDelayMs
        );
        logger.info(`API overloaded, retrying in ${delay / 1000}s...`);
        await sleep(delay);
        continue;
      }

      throw error;
    }
  }

  logger.error(`Failed after ${RETRY_CONFIG.maxRetries} attempts: ${lastError?.message}`);
  throw new Error(`Max retries exhausted. Last error: ${lastError?.message}`);
}

/**
 * Build user prompt with cognitive loop initialization
 */
function buildUserPrompt(params: {
  target: string;
  objective: string;
  vulnerabilityClass: VulnerabilityClass;
  authenticationInfo?: MetaVulnerabilityTestInput['authenticationInfo'];
  authenticationInstructions?: string;
}): string {
  const { target, objective, vulnerabilityClass, authenticationInfo, authenticationInstructions } = params;

  let prompt = `# Testing Assignment

**Target:** ${target}
**Objective:** ${objective}
**Vulnerability Class:** ${getVulnerabilityClassName(vulnerabilityClass)}

## Your Task

Test for ${getVulnerabilityClassName(vulnerabilityClass)} vulnerabilities using the cognitive loop:

1. **Create initial plan** with store_plan (phases: Recon, Test, Exploit)
2. **Form hypothesis** before each action (state confidence 0-100%)
3. **Validate results** after each action (update confidence)
4. **Create POC** when confidence >80% (bash preferred)
5. **Document finding** after successful POC
6. **Track adaptations** (store_adaptation for meta-prompting)
7. **Complete** by calling complete_testing

`;

  if (authenticationInstructions) {
    prompt += `## Authentication Instructions

${authenticationInstructions}

**Include authentication in all POC scripts.**
`;
  }

  if (authenticationInfo) {
    prompt += `## Authentication Details

- Method: ${authenticationInfo.method}
- Details: ${authenticationInfo.details}
${authenticationInfo.cookies ? `- Cookies: ${authenticationInfo.cookies}` : ''}
${authenticationInfo.headers ? `- Headers: ${authenticationInfo.headers}` : ''}
`;
  }

  prompt += `
## Critical Rules

- HYPOTHESIS before every tool call
- VALIDATION after every result
- Pivot at <50% confidence
- Direct-first economics (minimal steps)
- Max 3 POC attempts per approach

Begin with your initial plan, then start testing.
`;

  return prompt.trim();
}
