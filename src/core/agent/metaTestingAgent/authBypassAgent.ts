/**
 * AuthBypassAgent
 *
 * A specialized agent for testing authorization bypass vulnerabilities.
 * Spawned by the meta testing agent when authentication mechanisms are discovered.
 *
 * The agent intelligently discovers and tests:
 * - Parameter manipulation in auth flows
 * - Privilege escalation vectors
 * - Access control bypasses
 */

import { tool, hasToolCall } from 'ai';
import { z } from 'zod';
import { streamResponse, type AIModel } from '../../ai';
import type { ExecuteCommandOpts, ExecuteCommandResult, HttpRequestOpts, HttpRequestResult } from '../tools';
import { Logger } from '../logger';
import { join } from 'path';
import { existsSync, mkdirSync, writeFileSync } from 'fs';
import type { MetaTestingSessionInfo } from './types';
import { createDocumentFindingTool } from './pocTools';


export interface AuthBypassAgentInput {
  // Auth context generated by attack surface agent
  authContext: {
    endpoints: string[];
    observedParameters?: string[];
    credentials?: Array<{ username: string; password: string; context?: string }>;
    sessionInfo?: string;
    observations?: string;
  };

  baseUrl: string;

  objective?: string;

  session: MetaTestingSessionInfo;
}


export interface AuthBypassAgentResult {
  success: boolean;
  vulnerabilitiesFound: boolean;
  findings: Array<{
    type: string;
    description: string;
    evidence: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
  }>;
  findingPaths: string[];
  summary: string;
  error?: string;
}

const AUTH_BYPASS_SYSTEM_PROMPT = `You are a specialized Authorization Bypass Testing Agent. Your mission is to discover and exploit authorization vulnerabilities.

## Your Approach

### Phase 1: Discovery
- Analyze the authentication endpoints provided
- Make requests to understand the auth flow
- Identify ALL parameters (form fields, headers, cookies, query params)
- Look for hidden fields, privilege indicators, user type fields

### Phase 2: Parameter Analysis
For each parameter discovered:
- What does it control?
- Can it be manipulated?
- What values might it accept?
- Is it validated server-side?

### Phase 3: Systematic Testing
Test authorization bypass patterns:

**Parameter Manipulation**
- Modify values that control access/privileges
- Try unexpected values (different types, out of range)
- Test parameter pollution (duplicate parameters)
- Test parameter removal/addition

**Privilege Escalation**
- If you have low-privilege access, try accessing high-privilege functions
- Modify any privilege-related parameters
- Test direct access to protected endpoints

**Session/Token Attacks**
- Test session fixation
- Test token manipulation
- Test cross-user access

**IDOR Patterns**
- Test accessing resources belonging to other users
- Modify identifiers in requests

### Phase 4: Validation & Documentation
- Confirm bypasses work consistently
- Document exact steps to reproduce
- Capture evidence (requests/responses)

## Key Principles

1. **Be thorough**: Test every parameter you discover
2. **Be creative**: Think about what the server expects vs what you can send
3. **Cross-reference**: If credentials exist, test them with different parameter values
4. **Document everything**: Record all successful bypasses with evidence
`;

function buildAuthBypassPrompt(input: AuthBypassAgentInput): string {
  const { authContext, baseUrl, objective } = input;

  let prompt = `# Authorization Bypass Testing Assignment

## Target
- **Base URL**: ${baseUrl}

## Authentication Context Discovered

### Endpoints
${authContext.endpoints.map(e => `- ${e}`).join('\n')}

${authContext.observedParameters ? `### Parameters Observed
${authContext.observedParameters.map(p => `- ${p}`).join('\n')}` : ''}

${authContext.credentials && authContext.credentials.length > 0 ? `### Credentials Available
${authContext.credentials.map(c => `- ${c.username}:${c.password}${c.context ? ` (${c.context})` : ''}`).join('\n')}` : ''}

${authContext.sessionInfo ? `### Session Info
${authContext.sessionInfo}` : ''}

${authContext.observations ? `### Observations
${authContext.observations}` : ''}

${objective ? `## Specific Objective
${objective}` : ''}

## Your Task

1. **Explore** the authentication endpoints - make requests to understand the flow
2. **Discover** all parameters involved in authentication/authorization
3. **Analyze** which parameters might control access or privileges
4. **Test** authorization bypass patterns systematically
5. **Document** any vulnerabilities found

Start by making requests to understand the authentication mechanism, then systematically test for bypasses.
`;

  return prompt;
}

function saveAgentMessages(
  sessionRootPath: string,
  agentName: string,
  messages: any[],
  metadata?: Record<string, any>
): string {
  const subagentsDir = join(sessionRootPath, 'subagents');
  if (!existsSync(subagentsDir)) {
    mkdirSync(subagentsDir, { recursive: true });
  }

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const sanitizedName = agentName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
  const filename = `${sanitizedName}-${timestamp}.json`;
  const filepath = join(subagentsDir, filename);

  writeFileSync(filepath, JSON.stringify({
    agentName,
    timestamp: new Date().toISOString(),
    ...metadata,
    messages,
  }, null, 2));

  return filepath;
}

export async function runAuthBypassAgent(opts: {
  input: AuthBypassAgentInput;
  model: AIModel;
  toolOverride?: {
    execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
  };
  abortSignal?: AbortSignal;
}): Promise<AuthBypassAgentResult> {
  const { input, model, toolOverride, abortSignal } = opts;
  const { session } = input;

  const logger = new Logger(
    { id: session.id, rootPath: session.rootPath, logsPath: session.logsPath } as any,
    'auth-bypass-agent.log'
  );

  logger.info(`Starting AuthBypassAgent for ${input.baseUrl}`);
  logger.info(`Auth endpoints: ${input.authContext.endpoints.join(', ')}`);

  // Create document_finding tool
  const { document_finding, findingPaths } = createDocumentFindingTool(session, logger, input.baseUrl);

  // Create http_request tool
  const httpRequest = tool({
    name: 'http_request',
    description: 'Make HTTP requests to test authorization',
    inputSchema: z.object({
      url: z.string().describe('The URL to request'),
      method: z.enum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']).default('GET'),
      headers: z.record(z.string(), z.string()).optional(),
      body: z.string().optional(),
      followRedirects: z.boolean().default(false),
      timeout: z.number().default(10000),
      toolCallDescription: z.string().describe('What this request is testing'),
    }),
    execute: async ({ url, method, headers, body, followRedirects, timeout, toolCallDescription }) => {
      const headers_ = (headers || {}) as Record<string, string>;
      if (toolOverride?.http_request) {
        return toolOverride.http_request({ url, method, headers: headers_, body, followRedirects, timeout, toolCallDescription });
      }

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        const response = await fetch(url, {
          method,
          headers: headers_,
          body: body || undefined,
          redirect: followRedirects ? 'follow' : 'manual',
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        const responseHeaders: Record<string, string> = {};
        response.headers.forEach((value, key) => {
          responseHeaders[key] = value;
        });

        const responseBody = await response.text();

        return {
          success: true,
          status: response.status,
          statusText: response.statusText,
          headers: responseHeaders,
          body: responseBody.substring(0, 8000),
          url: response.url,
          redirected: response.redirected,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          url,
          status: 0,
          statusText: '',
          headers: {},
          body: '',
          redirected: false,
        };
      }
    },
  });

  // Completion tool
  const findings: AuthBypassAgentResult['findings'] = [];
  let testingSummary = '';

  const complete_testing = tool({
    name: 'complete_testing',
    description: 'Signal that authorization bypass testing is complete',
    inputSchema: z.object({
      summary: z.string().describe('Summary of testing performed'),
      bypassesFound: z.array(z.object({
        type: z.string().describe('Type of bypass found'),
        description: z.string(),
        evidence: z.string(),
        severity: z.enum(['critical', 'high', 'medium', 'low']),
      })).describe('Authorization bypasses found'),
    }),
    execute: async ({ summary, bypassesFound }) => {
      testingSummary = summary;
      findings.push(...bypassesFound);
      logger.info(`Auth bypass testing complete: ${bypassesFound.length} bypasses found`);
      return { success: true, message: 'Testing completed' };
    },
  });

  const tools = {
    http_request: httpRequest,
    document_finding,
    complete_testing,
  };

  const userPrompt = buildAuthBypassPrompt(input);

  try {
    const streamResult = streamResponse({
      prompt: userPrompt,
      system: AUTH_BYPASS_SYSTEM_PROMPT,
      model,
      tools,
      stopWhen: hasToolCall('complete_testing'),
      abortSignal,
      silent: true,
    });

    // Consume stream
    for await (const chunk of streamResult.fullStream) {
      if (chunk.type === 'tool-call') {
        logger.info(`[Tool Call] ${chunk.toolName}`);
      }
    }

    // Save messages
    try {
      const response = await streamResult.response;
      if (response.messages?.length > 0) {
        saveAgentMessages(
          session.rootPath,
          'auth-bypass-agent',
          response.messages,
          {
            baseUrl: input.baseUrl,
            endpoints: input.authContext.endpoints,
            findingsCount: findings.length,
          }
        );
      }
    } catch (e: any) {
      logger.error(`Failed to save messages: ${e.message}`);
    }

    return {
      success: true,
      vulnerabilitiesFound: findings.length > 0,
      findings,
      findingPaths,
      summary: testingSummary || `Authorization bypass testing completed for ${input.baseUrl}`,
    };

  } catch (error: any) {
    logger.error(`AuthBypassAgent error: ${error.message}`);
    return {
      success: false,
      vulnerabilitiesFound: findings.length > 0,
      findings,
      findingPaths,
      summary: `Testing failed: ${error.message}`,
      error: error.message,
    };
  }
}

export function createAuthBypassTool(
  sessionInfo: MetaTestingSessionInfo,
  logger: Logger,
  model: AIModel,
  toolOverride?: {
    execute_command?: (opts: ExecuteCommandOpts) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
  }
) {
  return tool({
    name: 'auth_bypass_test',
    description: `Spawn a specialized Authorization Bypass Testing Agent.

Use this tool when you discover authentication endpoints or mechanisms that warrant deeper authorization testing.

The agent will:
- Analyze authentication flows and discover parameters
- Systematically test for authorization bypasses
- Test privilege escalation and access control weaknesses
- Document any vulnerabilities found

Provide the authentication context you've discovered (endpoints, parameters, credentials if any).`,

    inputSchema: z.object({
      authContext: z.object({
        endpoints: z.array(z.string()).describe('Authentication-related endpoints discovered'),
        observedParameters: z.array(z.string()).optional().describe('Parameters observed in auth flows'),
        credentials: z.array(z.object({
          username: z.string(),
          password: z.string(),
          context: z.string().optional(),
        })).optional().describe('Any credentials discovered'),
        sessionInfo: z.string().optional().describe('Session or cookie information'),
        observations: z.string().optional().describe('Any other relevant observations about the auth mechanism'),
      }).describe('Authentication context discovered during reconnaissance'),
      baseUrl: z.string().describe('Base URL of the target'),
      objective: z.string().optional().describe('Specific authorization testing objective'),
      toolCallDescription: z.string().describe('Why you are spawning the auth bypass agent'),
    }),

    execute: async (input) => {
      logger.info(`Spawning AuthBypassAgent for ${input.baseUrl}`);

      const result = await runAuthBypassAgent({
        input: {
          authContext: input.authContext,
          baseUrl: input.baseUrl,
          objective: input.objective,
          session: sessionInfo,
        },
        model,
        toolOverride,
      });

      return {
        success: result.success,
        vulnerabilitiesFound: result.vulnerabilitiesFound,
        findingsCount: result.findings.length,
        findings: result.findings,
        summary: result.summary,
        error: result.error,
      };
    },
  });
}
